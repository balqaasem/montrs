AgentSnapshot {
    project_name: "app",
    timestamp: 2026-01-31T09:00:54.760606600Z,
    framework_version: "0.1.0",
    structure: [
        FileEntry {
            path: ".github\\actions\\build\\action.yml",
            description: None,
        },
        FileEntry {
            path: ".github\\workflows\\ci.yml",
            description: None,
        },
        FileEntry {
            path: ".gitignore",
            description: None,
        },
        FileEntry {
            path: "Cargo.lock",
            description: None,
        },
        FileEntry {
            path: "Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "Craft prompts my agent to do these copy 2.txt",
            description: None,
        },
        FileEntry {
            path: "docs\\agent\\agent-first.md",
            description: None,
        },
        FileEntry {
            path: "docs\\agent\\agentic-workflows.md",
            description: None,
        },
        FileEntry {
            path: "docs\\agent\\app-developer-prompt.md",
            description: None,
        },
        FileEntry {
            path: "docs\\agent\\appspec.md",
            description: None,
        },
        FileEntry {
            path: "docs\\agent\\framework-contributor-prompt.md",
            description: None,
        },
        FileEntry {
            path: "docs\\agent\\index.md",
            description: None,
        },
        FileEntry {
            path: "docs\\agent\\mcp-setup.md",
            description: None,
        },
        FileEntry {
            path: "docs\\agent\\metadata.md",
            description: None,
        },
        FileEntry {
            path: "docs\\agent\\onboarding.md",
            description: None,
        },
        FileEntry {
            path: "docs\\agent\\prompt-usage.md",
            description: None,
        },
        FileEntry {
            path: "docs\\agent\\spec.md",
            description: None,
        },
        FileEntry {
            path: "docs\\agent\\workflows\\adding-features.md",
            description: None,
        },
        FileEntry {
            path: "docs\\agent\\workflows\\fixing-errors.md",
            description: None,
        },
        FileEntry {
            path: "docs\\agent\\workflows\\new-projects.md",
            description: None,
        },
        FileEntry {
            path: "docs\\agent\\workflows\\restructuring.md",
            description: None,
        },
        FileEntry {
            path: "docs\\architecture\\overview.md",
            description: None,
        },
        FileEntry {
            path: "docs\\architecture\\packages.md",
            description: None,
        },
        FileEntry {
            path: "docs\\architecture\\philosophy.md",
            description: None,
        },
        FileEntry {
            path: "docs\\community\\contributing.md",
            description: None,
        },
        FileEntry {
            path: "docs\\community\\deployment.md",
            description: None,
        },
        FileEntry {
            path: "docs\\community\\packages-contribution.md",
            description: None,
        },
        FileEntry {
            path: "docs\\core\\errors.md",
            description: None,
        },
        FileEntry {
            path: "docs\\core\\plates.md",
            description: None,
        },
        FileEntry {
            path: "docs\\core\\router.md",
            description: None,
        },
        FileEntry {
            path: "docs\\core\\schema.md",
            description: None,
        },
        FileEntry {
            path: "docs\\getting-started\\first-30-minutes.md",
            description: None,
        },
        FileEntry {
            path: "docs\\getting-started\\golden-path.md",
            description: None,
        },
        FileEntry {
            path: "docs\\getting-started\\introduction.md",
            description: None,
        },
        FileEntry {
            path: "docs\\guides\\common-mistakes.md",
            description: None,
        },
        FileEntry {
            path: "docs\\index.md",
            description: None,
        },
        FileEntry {
            path: "docs\\orm\\async.md",
            description: None,
        },
        FileEntry {
            path: "docs\\orm\\backends.md",
            description: None,
        },
        FileEntry {
            path: "docs\\orm\\index.md",
            description: None,
        },
        FileEntry {
            path: "docs\\testing\\benchmarking.md",
            description: None,
        },
        FileEntry {
            path: "docs\\testing\\index.md",
            description: None,
        },
        FileEntry {
            path: "docs\\tooling\\cli.md",
            description: None,
        },
        FileEntry {
            path: "docs\\tooling\\fmt.md",
            description: None,
        },
        FileEntry {
            path: "docs\\tooling\\tasks.md",
            description: None,
        },
        FileEntry {
            path: "LICENSE-APACHE",
            description: None,
        },
        FileEntry {
            path: "LICENSE-MIT",
            description: None,
        },
        FileEntry {
            path: "packages\\agent\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "packages\\agent\\docs\\agent-guide.md",
            description: None,
        },
        FileEntry {
            path: "packages\\agent\\docs\\design-system.md",
            description: None,
        },
        FileEntry {
            path: "packages\\agent\\docs\\invariants.md",
            description: None,
        },
        FileEntry {
            path: "packages\\agent\\README.md",
            description: None,
        },
        FileEntry {
            path: "packages\\agent\\src\\error_parser.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\agent\\src\\framework.rs",
            description: Some(
                "Framework Invariants & Documentation",
            ),
        },
        FileEntry {
            path: "packages\\agent\\src\\guides.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\agent\\src\\lib.rs",
            description: Some(
                "Reports a new error to the agent, creating or updating errorfile.json.",
            ),
        },
        FileEntry {
            path: "packages\\agent\\tests\\agent_test.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\agent\\tests\\invariant_test.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\bench\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "packages\\bench\\docs\\agent-guide.md",
            description: None,
        },
        FileEntry {
            path: "packages\\bench\\docs\\invariants.md",
            description: None,
        },
        FileEntry {
            path: "packages\\bench\\README.md",
            description: None,
        },
        FileEntry {
            path: "packages\\bench\\src\\config.rs",
            description: Some(
                "Parses a duration from a string (in seconds).",
            ),
        },
        FileEntry {
            path: "packages\\bench\\src\\lib.rs",
            description: Some(
                "Professional-grade benchmarking utilities for MontRS.",
            ),
        },
        FileEntry {
            path: "packages\\bench\\src\\parameter.rs",
            description: Some(
                "Represents a benchmark parameter with a range of values.",
            ),
        },
        FileEntry {
            path: "packages\\bench\\src\\report.rs",
            description: Some(
                "A full benchmark report containing system info and results.",
            ),
        },
        FileEntry {
            path: "packages\\bench\\src\\runner.rs",
            description: Some(
                "The main entry point for running benchmarks.",
            ),
        },
        FileEntry {
            path: "packages\\bench\\src\\stats.rs",
            description: Some(
                "Statistical analysis of benchmark results.",
            ),
        },
        FileEntry {
            path: "packages\\bench\\src\\sys.rs",
            description: Some(
                "Captures system information for the benchmark report.",
            ),
        },
        FileEntry {
            path: "packages\\bench\\src\\weights.rs",
            description: Some(
                "Weight utilities for resource accounting and performance modeling.",
            ),
        },
        FileEntry {
            path: "packages\\bench\\tests\\config_priority.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\bench\\tests\\integration_test.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\docs\\agent-command-specs.md",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\docs\\agent-guide.md",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\docs\\invariants.md",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\docs\\mcp-server-design.md",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\docs\\optimization-report.md",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\README.md",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\bin\\cargo-montrs.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\bin\\montrs.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\command\\agent.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\command\\bench.rs",
            description: Some(
                "Bench command handler.",
            ),
        },
        FileEntry {
            path: "packages\\cli\\src\\command\\build.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\command\\e2e.rs",
            description: Some(
                "E2E test command.",
            ),
        },
        FileEntry {
            path: "packages\\cli\\src\\command\\expand.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\command\\fmt.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\command\\generate.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\command\\mcp.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\command\\mod.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\command\\new.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\command\\run.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\command\\serve.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\command\\sketch.rs",
            description: Some(
                "This file contains an explicit, deterministic, single-file plate definition.",
            ),
        },
        FileEntry {
            path: "packages\\cli\\src\\command\\spec.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\command\\test.rs",
            description: Some(
                "Test command implementation for MontRS.",
            ),
        },
        FileEntry {
            path: "packages\\cli\\src\\command\\upgrade.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\command\\watch.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\config\\mod.rs",
            description: Some(
                "Configuration plate for MontRS.",
            ),
        },
        FileEntry {
            path: "packages\\cli\\src\\config\\tailwind.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\error.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\ext\\mod.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\lib.rs",
            description: Some(
                "Build artifacts in release mode, with optimizations.",
            ),
        },
        FileEntry {
            path: "packages\\cli\\src\\mcp\\mod.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\mcp\\protocol.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\cli\\src\\utils.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\core\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "packages\\core\\docs\\agent-guide.md",
            description: None,
        },
        FileEntry {
            path: "packages\\core\\docs\\invariants.md",
            description: None,
        },
        FileEntry {
            path: "packages\\core\\README.md",
            description: None,
        },
        FileEntry {
            path: "packages\\core\\src\\env.rs",
            description: Some(
                "montrs-core/src/env.rs: Typed environment variable management.",
            ),
        },
        FileEntry {
            path: "packages\\core\\src\\features.rs",
            description: Some(
                "montrs-core/src/features.rs: Dynamic feature flags and user segmentation.",
            ),
        },
        FileEntry {
            path: "packages\\core\\src\\lib.rs",
            description: Some(
                "montrs-core: The core architectural engine for MontRS.",
            ),
        },
        FileEntry {
            path: "packages\\core\\src\\limiter.rs",
            description: Some(
                "montrs-core/src/limiter.rs: Rate limiting primitives.",
            ),
        },
        FileEntry {
            path: "packages\\core\\src\\router.rs",
            description: Some(
                "montrs-core/src/router.rs: Explicit routing primitives inspired by Remix.",
            ),
        },
        FileEntry {
            path: "packages\\core\\src\\validation.rs",
            description: Some(
                "Errors that can occur during schema validation.",
            ),
        },
        FileEntry {
            path: "packages\\core\\tests\\discovery_test.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\core\\tests\\router_test.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\fmt\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "packages\\fmt\\docs\\agent-guide.md",
            description: None,
        },
        FileEntry {
            path: "packages\\fmt\\docs\\invariants.md",
            description: None,
        },
        FileEntry {
            path: "packages\\fmt\\README.md",
            description: None,
        },
        FileEntry {
            path: "packages\\fmt\\src\\bin\\montrs-fmt.rs",
            description: Some(
                "Files or directories to format",
            ),
        },
        FileEntry {
            path: "packages\\fmt\\src\\comments.rs",
            description: Some(
                "Extracts all comments from the source string.",
            ),
        },
        FileEntry {
            path: "packages\\fmt\\src\\config.rs",
            description: Some(
                "Load settings using the \"Cascade of Truth\":",
            ),
        },
        FileEntry {
            path: "packages\\fmt\\src\\lib.rs",
            description: Some(
                "Formats a single Rust file.",
            ),
        },
        FileEntry {
            path: "packages\\fmt\\src\\macro_fmt.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\fmt\\tests\\integration.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\montrs\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "packages\\montrs\\docs\\invariants.md",
            description: None,
        },
        FileEntry {
            path: "packages\\montrs\\src\\bin\\cargo-montrs.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\montrs\\src\\bin\\montrs.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\montrs\\src\\lib.rs",
            description: Some(
                "The MontRS Framework - A full-stack Rust framework.",
            ),
        },
        FileEntry {
            path: "packages\\orm\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "packages\\orm\\docs\\agent-guide.md",
            description: None,
        },
        FileEntry {
            path: "packages\\orm\\docs\\invariants.md",
            description: None,
        },
        FileEntry {
            path: "packages\\orm\\README.md",
            description: None,
        },
        FileEntry {
            path: "packages\\orm\\src\\lib.rs",
            description: Some(
                "montrs-orm: A trait-driven ORM layer for MontRS.",
            ),
        },
        FileEntry {
            path: "packages\\schema\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "packages\\schema\\docs\\agent-guide.md",
            description: None,
        },
        FileEntry {
            path: "packages\\schema\\docs\\invariants.md",
            description: None,
        },
        FileEntry {
            path: "packages\\schema\\README.md",
            description: None,
        },
        FileEntry {
            path: "packages\\schema\\src\\lib.rs",
            description: Some(
                "montrs-schema: Procedural macros for schema validation in MontRS.",
            ),
        },
        FileEntry {
            path: "packages\\schema\\tests\\validation_test.rs",
            description: None,
        },
        FileEntry {
            path: "packages\\test\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "packages\\test\\docs\\agent-guide.md",
            description: None,
        },
        FileEntry {
            path: "packages\\test\\docs\\invariants.md",
            description: None,
        },
        FileEntry {
            path: "packages\\test\\README.md",
            description: None,
        },
        FileEntry {
            path: "packages\\test\\src\\e2e.rs",
            description: Some(
                "End-to-End (E2E) testing plate for MontRS.",
            ),
        },
        FileEntry {
            path: "packages\\test\\src\\integration.rs",
            description: Some(
                "Integration testing plate for MontRS.",
            ),
        },
        FileEntry {
            path: "packages\\test\\src\\lib.rs",
            description: Some(
                "# montrs-test",
            ),
        },
        FileEntry {
            path: "packages\\test\\src\\unit.rs",
            description: Some(
                "Production-grade unit testing utilities for MontRS.",
            ),
        },
        FileEntry {
            path: "packages\\utils\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "packages\\utils\\docs\\invariants.md",
            description: None,
        },
        FileEntry {
            path: "packages\\utils\\src\\lib.rs",
            description: Some(
                "Reusable utilities for the MontRS framework.",
            ),
        },
        FileEntry {
            path: "prompt.md",
            description: None,
        },
        FileEntry {
            path: "README.md",
            description: None,
        },
        FileEntry {
            path: "rust-toolchain.toml",
            description: None,
        },
        FileEntry {
            path: "templates\\default\\.gitignore",
            description: None,
        },
        FileEntry {
            path: "templates\\default\\.vscode\\settings.json",
            description: None,
        },
        FileEntry {
            path: "templates\\default\\app\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "templates\\default\\app\\src\\main.rs",
            description: None,
        },
        FileEntry {
            path: "templates\\default\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "templates\\default\\e2e\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "templates\\default\\e2e\\src\\main.rs",
            description: None,
        },
        FileEntry {
            path: "templates\\default\\montrs.toml",
            description: None,
        },
        FileEntry {
            path: "templates\\default\\README.md",
            description: None,
        },
        FileEntry {
            path: "templates\\default\\style\\main.css",
            description: None,
        },
        FileEntry {
            path: "templates\\default\\tailwind.toml",
            description: None,
        },
        FileEntry {
            path: "templates\\todo\\.gitignore",
            description: None,
        },
        FileEntry {
            path: "templates\\todo\\.vscode\\settings.json",
            description: None,
        },
        FileEntry {
            path: "templates\\todo\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "templates\\todo\\e2e\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "templates\\todo\\e2e\\src\\lib.rs",
            description: None,
        },
        FileEntry {
            path: "templates\\todo\\e2e\\tests\\e2e.rs",
            description: None,
        },
        FileEntry {
            path: "templates\\todo\\montrs.toml",
            description: None,
        },
        FileEntry {
            path: "templates\\todo\\README.md",
            description: None,
        },
        FileEntry {
            path: "templates\\todo\\src\\main.rs",
            description: Some(
                "todo-example: A comprehensive example demonstrating MontRS features.",
            ),
        },
        FileEntry {
            path: "templates\\todo\\style\\main.css",
            description: None,
        },
        FileEntry {
            path: "templates\\todo\\tailwind.toml",
            description: None,
        },
        FileEntry {
            path: "templates\\workspace\\.gitignore",
            description: None,
        },
        FileEntry {
            path: "templates\\workspace\\.vscode\\settings.json",
            description: None,
        },
        FileEntry {
            path: "templates\\workspace\\apps\\web\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "templates\\workspace\\apps\\web\\src\\main.rs",
            description: None,
        },
        FileEntry {
            path: "templates\\workspace\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "templates\\workspace\\e2e\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "templates\\workspace\\e2e\\src\\main.rs",
            description: None,
        },
        FileEntry {
            path: "templates\\workspace\\montrs.toml",
            description: None,
        },
        FileEntry {
            path: "templates\\workspace\\packages\\ui\\Cargo.toml",
            description: None,
        },
        FileEntry {
            path: "templates\\workspace\\packages\\ui\\src\\lib.rs",
            description: Some(
                "Shared UI components for the workspace.",
            ),
        },
        FileEntry {
            path: "templates\\workspace\\README.md",
            description: None,
        },
        FileEntry {
            path: "templates\\workspace\\style\\main.css",
            description: None,
        },
        FileEntry {
            path: "templates\\workspace\\tailwind.toml",
            description: None,
        },
    ],
    plates: [
        PlateSummary {
            name: "TodoPlate",
            description: "todo-example: A comprehensive example demonstrating MontRS features.",
            dependencies: [],
            metadata: {},
        },
    ],
    routes: [
        RouteSummary {
            path: "(impl) UserRoute",
            kind: "Route",
            description: "Heuristically discovered Route: UserRoute",
            input_schema: None,
            output_schema: None,
            params_schema: None,
            loader_output_schema: None,
            action_input_schema: None,
            action_output_schema: None,
            metadata: {},
        },
        RouteSummary {
            path: "(impl) TodoRoute",
            kind: "Route",
            description: "Heuristically discovered Route: TodoRoute",
            input_schema: None,
            output_schema: None,
            params_schema: None,
            loader_output_schema: None,
            action_input_schema: None,
            action_output_schema: None,
            metadata: {},
        },
    ],
    packages: [
        PackageSummary {
            name: "agent",
            path: "packages\\agent",
            invariants: Some(
                "# Agent Package Invariants\n\n## 1. Responsibility\n`montrs-agent` is the \"describer\" and \"recorder\". It translates the state of a MontRS project into machine-readable formats.\n\n## 2. Invariants\n- **Read-Only by Default**: This package should not modify the user's source code directly. It generates metadata, snapshots, and diffs for external application.\n- **Inference-Free**: This package must NOT contain logic for calling LLMs or performing AI inference. It only prepares the context for those models.\n- **Source of Truth**: The `AgentManager` is the sole authority for generating the `agent.json` specification.\n- **Versioned Errors**: Error captures (errorfiles) must be versioned and include the full context required for an agent to propose a fix.\n\n## 3. Boundary Definitions\n- **In-Scope**: Project snapshotting, error context capturing, tool specification generation.\n- **Out-of-Scope**: Code modification, LLM orchestration, CLI command execution.\n\n## 4. Agent Guidelines\n- When extending the snapshot, ensure new fields are optional or have sensible defaults to maintain backward compatibility.\n- Ensure that any data captured in `agent.json` is derived directly from the source or CLI metadata.\n",
            ),
            description: None,
        },
        PackageSummary {
            name: "bench",
            path: "packages\\bench",
            invariants: Some(
                "# Bench Package Invariants\n\n## 1. Responsibility\n`montrs-bench` provides tools for measuring performance and ensuring no regressions in framework efficiency.\n\n## 2. Invariants\n- **Statistical Significance**: Benchmarking results must be based on a sufficient sample size and provide variance data.\n- **Environment Isolation**: Benchmarks should attempt to minimize noise from background processes.\n\n## 3. Boundary Definitions\n- **In-Scope**: Performance measurement, regression detection, profiling hooks.\n- **Out-of-Scope**: Code optimization logic.\n",
            ),
            description: None,
        },
        PackageSummary {
            name: "cli",
            path: "packages\\cli",
            invariants: Some(
                "# CLI Package Invariants\n\n## 1. Responsibility\n`montrs-cli` is the orchestration hub. It coordinates project lifecycles, builds, and agent-specific metadata generation.\n\n## 2. Invariants\n- **Delegated Logic**: Business and framework logic must reside in `montrs-core`. The CLI only handles orchestration and execution.\n- **Idempotency**: Scaffolding and generation commands should be idempotent where possible. Running `montrs generate` twice should not result in corrupted state.\n- **Agent Synchronization**: Any command that modifies project structure or configuration MUST trigger an update to the `.agent/` directory.\n- **Subcommand Isolation**: Commands (e.g., `build`, `serve`, `generate`) should remain modular and not share mutable state.\n- **External Tooling**: The CLI must wrap external tools (cargo, wasm-pack) rather than reimplementing their functionality.\n\n## 3. Boundary Definitions\n- **In-Scope**: CLI argument parsing, command execution, template management, task running.\n- **Out-of-Scope**: Application business logic, core framework trait definitions, direct code compilation.\n\n## 4. Agent Guidelines\n- Always verify that a command has a corresponding spec in `command/mod.rs`.\n- When adding a new command, ensure it implements proper error reporting via `AgentError`.\n- Use the `utils.rs` helpers for common file operations to ensure consistency.\n",
            ),
            description: None,
        },
        PackageSummary {
            name: "core",
            path: "packages\\core",
            invariants: Some(
                "# Core Package Invariants\n\n## 1. Responsibility\n`montrs-core` is the foundational engine of the framework. It defines the core traits, data structures, and contracts that all other packages must follow.\n\n## 2. Invariants\n- **Zero Local Dependencies**: This package must remain the root of the workspace. It cannot depend on any other package in `packages/`.\n- **Trait-Driven Design**: All framework capabilities (Plates, Routes, Config) must be defined via traits to ensure extensibility and agent-readiness.\n- **Mandatory Metadata**: Every public trait intended for application use MUST implement `.description()` and `.metadata()` methods.\n- **Structured Errors**: All error types must implement the `AgentError` trait, providing stable error codes and suggested fixes.\n- **IO Abstraction**: This package must NOT implement concrete IO (DB drivers, file system logic). It only defines the interfaces.\n\n## 3. Boundary Definitions\n- **In-Scope**: Trait definitions, routing logic, validation primitives, error trait definitions.\n- **Out-of-Scope**: UI rendering, DB implementations, CLI commands, agent inference.\n\n## 4. Agent Guidelines\n- When adding a new trait, ensure it is documented with `description()` so other agents can discover it.\n- Never introduce a dependency on another `montrs-*` package here.\n- Use the `validation.rs` primitives for any new data structures.\n",
            ),
            description: None,
        },
        PackageSummary {
            name: "fmt",
            path: "packages\\fmt",
            invariants: Some(
                "# Formatter Package Invariants\n\n## 1. Responsibility\n`montrs-fmt` ensures a consistent, comment-preserving code style across the MontRS ecosystem, with special support for `view!` macros.\n\n## 2. Invariants\n- **Comment Preservation**: The formatter MUST NOT strip non-doc comments. Preserving developer intent is a priority over \"perfect\" whitespace.\n- **Logical Purity**: The formatter MUST NOT change the logical structure or behavior of the code. It is strictly a whitespace and layout tool.\n- **Idempotency**: Formatting a file multiple times with the same configuration must result in zero changes after the first pass.\n- **The Cascade of Truth**: Configuration must follow the hierarchical resolution (Workspace -> Project -> File) defined in the \"Cascade of Truth\".\n\n## 3. Boundary Definitions\n- **In-Scope**: Rust code formatting, `view!` macro (RSTML) formatting, comment handling.\n- **Out-of-Scope**: Linting, code analysis, auto-fixing of logic errors.\n\n## 4. Agent Guidelines\n- When generating code, you can rely on `montrs-fmt` to clean up the layout, but you must provide the comments yourself.\n- If a formatting error occurs, check the `FormatError` for specific `AgentError` metadata.\n",
            ),
            description: None,
        },
        PackageSummary {
            name: "montrs",
            path: "packages\\montrs",
            invariants: Some(
                "# MontRS Wrapper Package Invariants\n\n## 1. Responsibility\nThe `montrs` package is a high-level wrapper that provides the primary entry point for users consuming the framework as a single dependency.\n\n## 2. Invariants\n- **Clean Re-exports**: This package must cleanly re-export the public API of core packages (`core`, `orm`, `agent`) to provide a unified experience.\n- **Minimal Logic**: This package should contain minimal unique logic, acting primarily as a facade.\n\n## 3. Boundary Definitions\n- **In-Scope**: Re-exports, high-level convenience macros, meta-documentation.\n- **Out-of-Scope**: Implementation of core framework features.\n",
            ),
            description: None,
        },
        PackageSummary {
            name: "orm",
            path: "packages\\orm",
            invariants: Some(
                "# ORM Package Invariants\n\n## 1. Responsibility\n`montrs-orm` provides a type-safe, agent-readable interface for database operations and migrations.\n\n## 2. Invariants\n- **Backend Agnostic**: Core traits must remain independent of specific database backends (SQL, NoSQL, etc.).\n- **Type-Safe Queries**: All queries should be validated at compile-time or through type-safe DSLs defined in this package.\n- **Deterministic Migrations**: Migration logic must be reversible and idempotent.\n\n## 3. Boundary Definitions\n- **In-Scope**: DB traits, migration orchestration, type-safe query builders.\n- **Out-of-Scope**: Direct network handling (delegated to drivers), application business logic.\n",
            ),
            description: None,
        },
        PackageSummary {
            name: "schema",
            path: "packages\\schema",
            invariants: Some(
                "# Schema Package Invariants\n\n## 1. Responsibility\n`montrs-schema` handles procedural macros for validation, serialization, and metadata generation.\n\n## 2. Invariants\n- **Compile-Time Validation**: Errors in schema definition must be caught at compile-time with clear error messages.\n- **Agent-Readable Metadata**: Macros must generate the necessary hooks for `montrs-agent` to understand data structures.\n- **Minimal Runtime Overhead**: Generated code should be as efficient as manually written equivalents.\n\n## 3. Boundary Definitions\n- **In-Scope**: Derive macros, attribute macros, validation logic generation.\n- **Out-of-Scope**: Runtime data processing (delegated to core/orm).\n",
            ),
            description: None,
        },
        PackageSummary {
            name: "test",
            path: "packages\\test",
            invariants: Some(
                "# Test Package Invariants\n\n## 1. Responsibility\n`montrs-test` provides the infrastructure for deterministic unit, integration, and e2e testing.\n\n## 2. Invariants\n- **Determinism**: Tests must be reproducible. Any non-deterministic behavior (time, random) must be mockable via `TestRuntime`.\n- **Isolation**: Tests should not leak state between runs.\n- **Agent-Verifiable**: Testing utilities should provide clear, machine-readable output for agents to verify their own changes.\n\n## 3. Boundary Definitions\n- **In-Scope**: Mocking traits, test runners, assertion libraries, e2e orchestration.\n- **Out-of-Scope**: Implementation of business logic being tested.\n",
            ),
            description: None,
        },
        PackageSummary {
            name: "utils",
            path: "packages\\utils",
            invariants: Some(
                "# Utils Package Invariants\n\n## 1. Responsibility\n`montrs-utils` contains generic, reusable utilities that are used across multiple packages in the workspace.\n\n## 2. Invariants\n- **Side-Effect Free**: Functions in this package should ideally be pure and free of side effects.\n- **Generic Utility**: Only include logic that is truly generic and not specific to a single framework component.\n- **High Stability**: As a low-level dependency, changes here must be carefully vetted for breaking impact.\n\n## 3. Boundary Definitions\n- **In-Scope**: String manipulation, collection helpers, common algorithm implementations.\n- **Out-of-Scope**: Framework-specific logic (Plates, Routes, etc.).\n",
            ),
            description: None,
        },
    ],
    agent_entry_point: Some(
        "# ðŸ¤– MontRS Agent Entry Point\r\n\r\nWelcome to the unified command center for MontRS Agents. This document is the \"Map of Maps\"â€”it defines the operational framework for how you should interact with the codebase based on your current intent.\r\n\r\n---\r\n\r\n## ðŸ§­ Operational Framework: \"What are you doing?\"\r\n\r\nChoose your path based on the task at hand. Do not attempt to \"wing it\"â€”follow the established workflows to maintain architectural integrity.\r\n\r\n### 1. I am fixing a Bug or Error\r\n- **Goal**: Identify, diagnose, and resolve a failure (compilation, runtime, or architectural).\r\n- **Primary Guide**: [Workflow: Fixing Errors](workflows/fixing-errors.md)\r\n- **Key Tools**: `montrs agent list-errors`, `montrs agent diff`.\r\n\r\n### 2. I am adding a New Feature\r\n- **Goal**: Extend the application or framework with new capabilities.\r\n- **Primary Guide**: [Workflow: Adding Features](workflows/adding-features.md)\r\n- **Key Tools**: `montrs generate plate`, `montrs generate route`, `montrs spec`.\r\n\r\n### 3. I am starting a New Project\r\n- **Goal**: Scaffold a fresh MontRS application from scratch.\r\n- **Primary Guide**: [Workflow: New Projects](workflows/new-projects.md)\r\n- **Key Tools**: `montrs new`.\r\n\r\n### 4. I am restructuring or Refactoring\r\n- **Goal**: Move logic, split plates, or improve architectural health without changing behavior.\r\n- **Primary Guide**: [Workflow: Restructuring](workflows/restructuring.md)\r\n- **Key Tools**: `montrs agent check`.\r\n\r\n---\r\n\r\n## ðŸŽ­ System Prompts (Your Identity)\r\n\r\nYour behavior is governed by your specific role. Read these to understand your constraints and core identity:\r\n\r\n- **[App Developer Prompt](app-developer-prompt.md)**: For building applications *using* MontRS.\r\n- **[Framework Contributor Prompt](framework-contributor-prompt.md)**: For developing and maintaining the *framework itself*.\r\n\r\n---\r\n\r\n## ðŸ›¡\u{fe0f} Foundational Knowledge\r\n\r\nBefore performing any action, ensure you are grounded in these core principles:\r\n\r\n- **[Agent-First Philosophy](agent-first.md)**: Why we prioritize machine-readability.\r\n- **[Framework Invariants](onboarding.md)**: The rules you must never break.\r\n- **[Spec Snapshot (agent.json)](spec.md)**: How to read the project's current state.\r\n- **[Metadata Standards](metadata.md)**: How to annotate code for discovery.\r\n\r\n---\r\n\r\n## ðŸ”Œ Tooling & Integration\r\n\r\n- **[MCP Setup & Access](mcp-setup.md)**: How to connect your capabilities to the project.\r\n- **[Agentic CLI Guide](agentic-workflows.md)**: Mastering the command-line loop.\r\n",
    ),
    documentation_snippets: {
        "packages/schema/docs/agent-guide.md": "# Agent Guide: montrs-schema\n\nThis guide helps agents use the declarative validation system of MontRS.\n\n## Core Concepts\n\n### 1. `#[derive(Schema)]`\nThe primary macro for defining validation rules. It generates a `validate(&self) -> Result<(), Vec<ValidationError>>` method.\n\n### 2. Validation Attributes\n- `min_len = N`: Validates string length.\n- `email`: Validates email format.\n- `regex = \"...\"`: Validates against a regular expression.\n- `custom = \"method\"`: Delegates to a custom method returning `Result<(), String>`.\n\n## Agent Usage Patterns\n\n### Defining a Validated Struct\nWhen generating data models, always include validation attributes to ensure data integrity.\n```rust\n#[derive(Schema, Serialize, Deserialize)]\npub struct ProjectConfig {\n    #[schema(min_len = 3)]\n    pub name: String,\n    #[schema(email)]\n    pub contact_email: String,\n}\n```\n\n### Handling Validation Errors\nIf `validate()` returns an error, it will contain a list of `ValidationError` variants. Use these to prompt the user or self-correct the input data.\n- `MinLength { field, min, actual }`\n- `InvalidEmail { field }`\n- `RegexMismatch { field, pattern }`\n- `Custom { field, message }`\n",
        "docs/architecture\\overview.md": "# MontRS Architecture: The \"Shape\" of a Framework\n\nMontRS is built on the principle that a framework should be a **specification** first, and an implementation second. This document outlines the core architectural layers and how they interact.\n\n---\n\n## ðŸ—\u{fe0f} The Layered Cake\n\n1.  **The Engine (`montrs-core`)**: Defines the foundational traits (`Plate`, `Loader`, `Action`, `AgentError`). It is the \"grammar\" of the framework.\n2.  **The Blueprint (`AppSpec`)**: A serializable representation of the entire application. It knows about every route, every plate, and every data schema.\n3.  **The Orchestrator (`montrs-cli`)**: The primary interface for developers. It uses the `AppSpec` to build, serve, and test the app.\n4.  **The Sidecar (`montrs-agent`)**: An agent-facing layer that consumes the `AppSpec` and produces machine-optimized context (`agent.json`, `tools.json`).\n\n---\n\n## ðŸ”„ The Lifecycle of a Request\n\nUnderstanding how a request moves through MontRS is key to building idiomatic apps.\n\n### 1. Discovery & Routing\nWhen a request arrives (or a command is run), the `Router` uses the `AppSpec` to find the matching `Plate` and its associated `Loader` or `Action`.\n\n### 2. The `Context` Object\nEvery `Loader` and `Action` receives a `Context`. This object is the \"glue\" that provides access to:\n- **Services**: Database pools, cache clients, or external APIs.\n- **Runtime**: Environment variables, current time, and configuration.\n- **Request Info**: Headers, parameters, and user session (if applicable).\n\n### 3. Execution Flow\n1.  **Validation**: `montrs-schema` validates the input before it reaches your logic.\n2.  **Logic**: Your `Loader` or `Action` implementation executes.\n3.  **Persistence**: The logic interacts with the `Database` via the `Context`.\n4.  **Response**: The output is serialized and returned to the caller.\n\n---\n\n## ðŸ§± Key Architectural Patterns\n\n### Specification-First Discovery\nMontRS does not rely on global state or hidden registration. Instead, it uses **Heuristic Discovery**. The CLI scans your `src/` directory for implementations of `Plate`, `Loader`, and `Action`. This ensures that the `AppSpec` is always a true reflection of your code.\n\n### Deterministic Runtimes\nIn a standard run, the `Context` provides access to real services. In a test run, the `TestRuntime` replaces these with mocks. Because your logic only interacts with traits (via `Context`), it remains unaware of whether it is running in production or a test environment.\n\n---\n\n## ðŸ¤– Agent-first by design\n\nArchitecture in MontRS is not just for humans. Every trait implementation is encouraged to provide metadata:\n\n```rust\nimpl Loader for MyLoader {\n    fn description(&self) -> Option<String> {\n        Some(\"Fetches user profile data by ID\".to_string())\n    }\n    \n    fn input_schema(&self) -> Option<Schema> {\n        Some(UserId::schema())\n    }\n}\n```\n\nThis metadata is picked up by `montrs-agent` and exposed to agents, allowing them to understand the *intent* and *contract* of the code without reading the entire implementation.\n",
        "docs/community\\contributing.md": "# Contributing to MontRS\n\nThank you for your interest in contributing to MontRS! This framework is built for the future of agent-assisted development, and we welcome contributions that strengthen this vision.\n\n## ðŸ› \u{fe0f} Development Environment\n\n1.  **Clone the Repo**:\n    ```bash\n    git clone https://github.com/montrs/montrs.git\n    cd montrs\n    ```\n2.  **Install Dependencies**:\n    Ensure you have Rust (latest stable) and the MontRS CLI installed locally.\n3.  **Run Tests**:\n    ```bash\n    cargo test --workspace\n    ```\n\n## ðŸ—\u{fe0f} Project Structure\n\nMontRS is a workspace with several packages. For a detailed breakdown of package boundaries and instructions on how to create new ones, see the **[Packages Contribution Guide](packages-contribution.md)**.\n\nThe workspace includes:\n-   `packages/core`: The architectural engine.\n-   `packages/cli`: The command-line interface.\n-   `packages/agent`: The Agent-First sidecar.\n-   `packages/schema`: Procedural macros for validation.\n-   `packages/orm`: The database layer.\n-   `packages/fmt`: The custom formatter.\n\n## ðŸ¤– Agent-First Contribution Guidelines\n\nWhen adding new features or packages, you **must** ensure they are Agent-ready:\n\n1.  **Implement `AgentError`**: All new error types should implement the `AgentError` trait with descriptive codes and suggested fixes.\n2.  **Add Metadata**: Provide `description()` and schema information for all new traits or plates.\n3.  **Update READMEs**: Follow the mandatory section structure for any new package README.\n4.  **Local Invariants**: Every package must maintain a `docs/invariants.md` file that defines its specific \"rules of engagement\" and architectural boundaries.\n5.  **Annotate Tools**: Use the `@agent-tool` marker in comments for any public function or struct that should be exposed to agents.\n\n## ðŸ§ª Testing Your Changes\n\nWe prioritize deterministic testing. If you add a new feature:\n1.  Add unit tests in the same file or a `tests/` directory.\n2.  Add integration tests in `packages/core/tests` or `packages/test`.\n3.  If it's a CLI change, verify it with a real project scaffolded via `montrs new`.\n\n## ðŸ“ Pull Request Process\n\n1.  **Fork and Branch**: Create a feature branch from `main`.\n2.  **Format Code**: Run `montrs fmt` before committing.\n3.  **Commit Messages**: Use clear, descriptive commit messages.\n4.  **Self-Audit**: Run `montrs spec` and check if your changes are correctly reflected in the generated `agent.json`.\n\n---\n\nTogether, we're building the first framework that truly speaks the language of both humans and machines.\n",
        "packages/bench/docs/agent-guide.md": "# Agent Guide: montrs-bench\n\nThis guide helps agents measure and optimize performance in MontRS.\n\n## Core Concepts\n\n### 1. BenchCase Trait\nImplement this trait to define a benchmark.\n- **Setup/Teardown**: Use these for non-timed resource management.\n- **Run**: The actual code to be measured.\n\n### 2. BenchRunner\nThe orchestrator that runs benchmarks and generates reports.\n\n### 3. Statistics\nProvides Mean, Median, P95, P99, etc. Use these to identify performance regressions.\n\n## Agent Usage Patterns\n\n### Defining a Benchmark\n```rust\npub struct MyBench;\n\n#[async_trait]\nimpl BenchCase for MyBench {\n    fn name(&self) -> &str { \"my_feature_performance\" }\n    async fn run(&self) -> anyhow::Result<()> {\n        // Code to measure\n        Ok(())\n    }\n}\n```\n\n### Analyzing Results\nWhen a benchmark is run, it generates a `Report`. Use this report to suggest optimizations.\n- **High Variance**: Suggests unstable environment or background tasks.\n- **High P99**: Suggests occasional blocking operations or resource contention.\n",
        "packages/core/docs/agent-guide.md": "# Agent Guide: montrs-core\n\nThis guide is designed to help agents understand and use the core building blocks of the MontRS framework.\n\n## Core Concepts\n\n### 1. The Plate Trait\nEvery MontRS component is a `Plate`. When building an app, you should define your logic within a struct that implements `Plate`.\n- **Metadata**: Always provide a descriptive name and metadata for agent discoverability.\n- **Dependencies**: Use `dependencies()` to declare other plates this plate requires. This prevents runtime panics and allows `montrs agent check` to verify your architecture.\n- **Initialization**: Use `init` for async setup logic.\n- **Routing**: Use `register_routes` to attach loaders and actions.\n\n### 2. The Unified Route Trait\n- **Consolidation**: A `Route` implementation unifies `Params`, `Loader`, `Action`, and `View`.\n- **Registration**: Use `router.register(MyRoute)` inside `Plate::register_routes`.\n- **Type Safety**: The `Route` trait ensures that the output of a `Loader` matches what the `View` expects, and that `Actions` have clearly defined input/output schemas.\n\n### 3. Loaders and Actions\n- **RouteLoader**: Read-only operations that fetch data. They should be deterministic and idempotent.\n- **RouteAction**: Write operations that modify state. They should include validation and error handling.\n- **Context**: Both receive `RouteContext`, which provides access to the application config and environment.\n\n### 4. Environment and Configuration\n- Use `EnvConfig` for type-safe environment variable access.\n- `EnvError` provides detailed agent-accessible metadata when variables are missing or invalid.\n\n### 5. Validation\n- Use the `Validate` trait for data integrity.\n- `ValidationError` is the standard way to report validation failures to the agent for self-correction.\n\n### 6. Local Invariants\nEvery package in the MontRS workspace contains a `docs/invariants.md` file.\n- **Rules of Engagement**: These files define the specific architectural boundaries and \"rules\" for that package.\n- **Mandatory Check**: Before modifying any package, you MUST read its `docs/invariants.md`.\n- **Consistency**: Your changes must not violate the invariants stated in these documents. If you introduce a new invariant, you must update the file.\n\n## Agent Usage Patterns\n\n### Generating a New Plate\nWhen asked to create a new feature or logical boundary:\n1.  **Use the CLI**: Run `montrs generate plate <name>`.\n2.  **Verify**: Ensure the plate file is created in `src/plates/<name>.rs`.\n3.  **Register**:\n    - Add `pub mod <name>;` to `src/plates/mod.rs`.\n    - Register it in `src/main.rs` using `.with_plate(Box::new(<Name>Plate))`.\n\n### Generating a New Route\nWhen asked to add a page or an endpoint:\n1.  **Use the CLI**: Run `montrs generate route <path> --plate <plate_name>`.\n2.  **Implementation**:\n    - The CLI generates a unified `Route` struct bundling `Params`, `Loader`, `Action`, and `View`.\n    - Customize the `load` and `act` logic in the generated file.\n3.  **Register**:\n    - Add `pub mod <route_name>;` to the plate's `routes/mod.rs`.\n    - Register it in the plate's `register_routes` method: `router.register(<RouteName>Route);`.\n\nExample of manual implementation (if not using CLI):\n```rust\npub struct UserRoute;\n\nimpl Route<AppConfig> for UserRoute {\n    type Params = UserParams;\n    type Loader = UserLoader;\n    type Action = UserAction;\n    type View = UserView;\n\n    fn path() -> &'static str { \"/users/:id\" }\n    fn loader(&self) -> Self::Loader { UserLoader }\n    fn action(&self) -> Self::Action { UserAction }\n    fn view(&self) -> Self::View { UserView }\n}\n```\n\n### Error Recovery\nIf you encounter an `AgentError`, check its `error_code` and `suggested_fixes`. The `explanation` field provides a structured reason for the failure.\n",
        "docs/agent\\app-developer-prompt.md": "# MontRS App Developer Agent System Prompt\n\nYou are a **Specialized MontRS App Developer AI Agent**. Your purpose is to assist developers in building high-quality, idiomatic, and robust applications using the MontRS framework.\n\n## ðŸŽ¯ Your Core Identity\nYou are an expert in the **Scaffolded Explicit** architecture and the **Loader/Action/Plate** pattern. You prioritize machine-readability, type safety, and architectural consistency.\n\n## ðŸ—\u{fe0f} Architectural Principles you MUST Follow\n- **Loader/Action Pattern**: Read operations are `Loaders`, write operations are `Actions`. No business logic should leak into UI or routing layers.\n- **Plate-Based Composition**: Applications are composed of `Plates` which own their services (DB, Network, etc.).\n- **State Locality**: Use `Signal<T>` for reactive state. Avoid global state or `static mut`.\n- **Invariants as Contract**: Every package and major feature has **Local Invariants** (`docs/invariants.md`). These are your \"rules of engagement\" for that specific context.\n- **Explicit over Implicit**: Everything in MontRS is explicit. No \"magic\" macros that hide complex logic.\n- **Agent-First**: Always implement `description()`, `input_schema()`, and `output_schema()` on your traits for better discovery.\n\n## ðŸ› \u{fe0f} Your Workflow\n\nYour actions are intent-driven. Before proceeding, identify your task and follow the corresponding specialized workflow:\n\n- **Adding a New Feature?** Follow [Workflow: Adding Features](workflows/adding-features.md).\n- **Fixing a Bug or Error?** Follow [Workflow: Fixing Errors](workflows/fixing-errors.md).\n- **Starting a New Project?** Follow [Workflow: New Projects](workflows/new-projects.md).\n- **Refactoring or Restructuring?** Follow [Workflow: Restructuring](workflows/restructuring.md).\n\n### General Operational Loop\nIf no specialized workflow applies, follow this standard loop:\n1.  **Observe**: Check for existing errors, bugs, or architectural violations using `montrs agent list-errors`.\n2.  **Contextualize**: \n    - Refresh and read the project snapshot using `montrs spec`.\n    - **Read Framework Invariants**: Consult the `docs/invariants.md` of the MontRS framework packages you are utilizing.\n3.  **Analyze**: Use the diagnostic tools (like `montrs agent diff`) to understand root causes of any issues found in Step 1.\n4.  **Implement**: Write the Rust code following the \"Golden Path\" (Schema -> Logic -> Route -> Metadata).\n5.  **Verify**: Run `montrs agent check` to ensure architectural integrity.\n\n## ðŸ”Œ Utilizing MCP and CLI\nYou have access to powerful agentic tools. Use them proactively:\n-   **MCP Tools**: Prefer using `agent_check`, `agent_diff`, and `get_project_snapshot` via the MCP server if available.\n-   **CLI Commands**: Use `montrs agent list-errors` to keep track of your progress on bug fixes.\n\n## ðŸ¤– Interaction Style\n- **Proactive**: If a requirement is ambiguous, suggest the most idiomatic MontRS implementation.\n- **Educational**: Explain *why* a specific pattern (like using a Plate) is used.\n- **Corrective**: If the user suggests an anti-pattern (like direct DB access in UI), gently guide them back to the Golden Path.\n\n## ðŸ“š Reference Documents (TODO!: Update to repo links)\n- [Condensed Onboarding](docs/agent/onboarding.md)\n- [Golden Path](docs/getting-started/golden-path.md)\n- [Router Guide](docs/core/router.md)\n- [Plates Guide](docs/core/plates.md)\n\n---\n*Remember: You are building for a future where humans and agents collaborate seamlessly. Keep your code clean, annotated, and machine-readable.*\n",
        "docs/core\\schema.md": "# Schema & Validation: Type-Safe Data\n\nMontRS leverages a declarative schema system powered by `montrs-schema`. It allows you to define data structures that are automatically validated at the boundaries of your application.\n\n---\n\n## ðŸ“œ The `#[derive(Schema)]` Macro\n\nThe core of the system is the `Schema` derive macro. It generates validation logic and machine-readable metadata for your structs.\n\n```rust\nuse montrs::prelude::*;\n\n#[derive(Schema, Serialize, Deserialize)]\npub struct CreateUserInput {\n    #[schema(min_len = 3, max_len = 50)]\n    pub username: String,\n    \n    #[schema(email)]\n    pub email: String,\n    \n    #[schema(min = 18)]\n    pub age: i32,\n}\n```\n\n---\n\n## âœ… Validation Lifecycle\n\n1.  **Incoming Request**: A JSON payload arrives at an `Action`.\n2.  **Deserialization**: The data is deserialized into the struct using `serde`.\n3.  **Validation**: The `validate()` method (generated by `#[derive(Schema)]`) is called.\n4.  **Error Handling**: If validation fails, a structured `ValidationError` (implementing `AgentError`) is returned, including details on which fields failed and why.\n\n---\n\n## ðŸ› \u{fe0f} Supported Constraints\n\n-   `min_len`, `max_len`: For strings and collections.\n-   `min`, `max`: For numeric values.\n-   `email`: Validates email format.\n-   `regex`: Matches against a custom regular expression.\n-   `custom`: Invokes a custom validation function.\n\n---\n\n## ðŸ› \u{fe0f} Practical Example: Using Schema in an Action\n\nHere is how you use a schema-validated struct in a real-world `Action`:\n\n```rust\nuse montrs::prelude::*;\nuse crate::models::User;\n\n#[derive(Schema, Serialize, Deserialize)]\npub struct UpdateProfileInput {\n    #[schema(min_len = 2)]\n    pub display_name: Option<String>,\n    #[schema(max_len = 255)]\n    pub bio: Option<String>,\n}\n\npub struct UpdateProfileAction;\n\n#[async_trait]\nimpl Action for UpdateProfileAction {\n    async fn call(&self, ctx: Context) -> Result<Value> {\n        // ctx.input() automatically deserializes and validates \n        // against UpdateProfileInput's constraints.\n        let input: UpdateProfileInput = ctx.input()?; \n        \n        let user_id = ctx.user_id()?;\n        let updated_user = db::update_profile(user_id, input).await?;\n        \n        Ok(json!(updated_user))\n    }\n}\n```\n\n---\n\n## ðŸ” Advanced Validation: Custom Rules\n\nSometimes built-in constraints aren't enough. You can define custom validation logic:\n\n```rust\n#[derive(Schema, Serialize, Deserialize)]\npub struct PasswordResetInput {\n    pub password: String,\n    #[schema(custom = \"validate_confirm_password\")]\n    pub confirm_password: String,\n}\n\nfn validate_confirm_password(input: &PasswordResetInput) -> Result<(), ValidationError> {\n    if input.password != input.confirm_password {\n        return Err(ValidationError::new(\"confirm_password\", \"Passwords must match\"));\n    }\n    Ok(())\n}\n```\n\n---\n\n## ðŸ¤– Agents and Schemas\n\nSchemas are the **API Contract**. In the `AppSpec`, every `Loader` and `Action` can specify its input and output schemas.\n\n### Common Agent Failure Modes\n- **Anti-Pattern**: Forgetting `#[derive(Schema)]` on a new input struct.\n  - *Fix*: Agents must ensure every struct used in `ctx.input()` implements `Schema`.\n- **Anti-Pattern**: Using `String` for data that has a known format (like email).\n  - *Fix*: Use `#[schema(email)]` to provide better hints to the validation engine and the agent.\n- **Anti-Pattern**: Complex logic inside the `Schema` definition.\n  - *Fix*: Use `custom` validation functions for complex logic to keep the struct definition clean and readable.\n",
        "packages/test/docs/agent-guide.md": "# Agent Guide: montrs-test\n\nThis guide helps agents write and run tests in MontRS.\n\n## Core Concepts\n\n### 1. TestEnv\nMock environment variables to test different configurations.\n```rust\nlet env = TestEnv::new();\nenv.set(\"KEY\", \"VALUE\");\n```\n\n### 2. Fixture Trait\nDefine setup and teardown logic for complex integration tests.\n\n### 3. E2E Testing\nUses Playwright for browser automation. \n- **Agent Recommendation**: Use `MontrsDriver` to interact with the UI during E2E tests.\n\n### 4. Assertions\nUse `expect(value).to_be(expected)` for fluent, agent-readable assertions.\n\n## Agent Usage Patterns\n\n### Generating Tests\nWhen asked to add tests for a new feature:\n1. Identify if it needs a unit test (logic only) or integration test (requires environment/db).\n2. Use `TestEnv` for configuration mocking.\n3. Use `run_fixture_test` if resources like databases are needed.\n\n### Debugging Failures\nIf a test fails with `TEST_EXPECTATION`, compare the actual and expected values provided in the `AgentError`.\n",
        "packages/schema/docs/invariants.md": "# Schema Package Invariants\n\n## 1. Responsibility\n`montrs-schema` handles procedural macros for validation, serialization, and metadata generation.\n\n## 2. Invariants\n- **Compile-Time Validation**: Errors in schema definition must be caught at compile-time with clear error messages.\n- **Agent-Readable Metadata**: Macros must generate the necessary hooks for `montrs-agent` to understand data structures.\n- **Minimal Runtime Overhead**: Generated code should be as efficient as manually written equivalents.\n\n## 3. Boundary Definitions\n- **In-Scope**: Derive macros, attribute macros, validation logic generation.\n- **Out-of-Scope**: Runtime data processing (delegated to core/orm).\n",
        "packages/cli/docs/optimization-report.md": "# MontRS Agent-First Optimization Report\r\n\r\nThis report analyzes friction points in the current MontRS design and proposes improvements to enhance agent autonomy and understanding.\r\n\r\n---\r\n\r\n## 1. Friction Point: Casing Inconsistency in Templates\r\n**Observation**: Some templates use PascalCase for component names but camelCase for internal variables, while HTML attributes are kebab-case.\r\n**Problem for Agents**: Agents may hallucinate casing styles based on surrounding code.\r\n**Proposed Improvement**: Enforce strict casing via `montrs-fmt` and `montrs-utils`. All HTML/Component attributes MUST be kebab-case. All Component names MUST be PascalCase, etc.\r\n**Justification**: Eliminates ambiguity. Agents can follow a simple, deterministic rule for naming and attribute access.\r\n\r\n---\r\n\r\n## Summary of Benefits\r\n\r\n| Change | Benefit for Agents | Benefit for Humans |\r\n| :--- | :--- | :--- |\r\n| Strict Casing | Deterministic naming rules | Consistent, professional-looking code |\r\n",
        "docs/agent\\workflows\\restructuring.md": "# Workflow: Restructuring Projects\r\n\r\nThis guide defines how to safely reorganize code, move routes, and refactor package boundaries in a MontRS environment.\r\n\r\n---\r\n\r\n## ðŸ“± For Application Developers\r\n\r\n1.  **Plan**: Identify which routes or services belong in a different `Plate`.\r\n2.  **Move Logic**: Relocate `Loader` or `Action` implementations to the target Plate.\r\n3.  **Update Routing**: \r\n    -   Remove route registration from the old Plate.\r\n    -   Add route registration to the new Plate.\r\n4.  **Sync**: Run `montrs spec` to update the architectural snapshot.\r\n5.  **Validate**: Run `montrs agent check`. This will detect if any dependencies are now broken or if routes are missing.\r\n6.  **Cleanup**: Remove any unused imports or services from the old Plate.\r\n\r\n---\r\n\r\n## ðŸ—\u{fe0f} For Framework Contributors\r\n\r\n1.  **Refactor Boundaries**: When moving logic between packages (e.g., from `core` to `utils`):\r\n    -   Update `Cargo.toml` dependencies for all affected packages.\r\n    -   Ensure public APIs remain stable or provide a migration path.\r\n2.  **Maintain Annotations**: Ensure `@agent-tool` markers are moved along with the code.\r\n3.  **Global Check**: Run `montrs agent doctor` for the entire workspace.\r\n4.  **Verification**: \r\n    -   Run `cargo test --workspace`.\r\n    -   Run `montrs spec` and compare the new `agent.json` with a previous version to ensure no unintended metadata loss.\r\n\r\n---\r\n\r\n## ðŸ¤– Agent Instructions (MCP)\r\n-   **Step 1**: `get_project_snapshot({})` to map current dependencies.\r\n-   **Step 2**: Apply structural changes.\r\n-   **Step 3**: `agent_check({})` to find broken invariants.\r\n-   **Step 4**: `agent_doctor({})` for workspace-wide health.\r\n",
        "packages/agent/docs/invariants.md": "# Agent Package Invariants\n\n## 1. Responsibility\n`montrs-agent` is the \"describer\" and \"recorder\". It translates the state of a MontRS project into machine-readable formats.\n\n## 2. Invariants\n- **Read-Only by Default**: This package should not modify the user's source code directly. It generates metadata, snapshots, and diffs for external application.\n- **Inference-Free**: This package must NOT contain logic for calling LLMs or performing AI inference. It only prepares the context for those models.\n- **Source of Truth**: The `AgentManager` is the sole authority for generating the `agent.json` specification.\n- **Versioned Errors**: Error captures (errorfiles) must be versioned and include the full context required for an agent to propose a fix.\n\n## 3. Boundary Definitions\n- **In-Scope**: Project snapshotting, error context capturing, tool specification generation.\n- **Out-of-Scope**: Code modification, LLM orchestration, CLI command execution.\n\n## 4. Agent Guidelines\n- When extending the snapshot, ensure new fields are optional or have sensible defaults to maintain backward compatibility.\n- Ensure that any data captured in `agent.json` is derived directly from the source or CLI metadata.\n",
        "docs/getting-started\\introduction.md": "# Getting Started with MontRS\n\nWelcome to MontRS! This guide will help you get your first application up and running in minutes.\n\n## ðŸ› \u{fe0f} Prerequisites\n\n- **Rust**: Ensure you have the latest stable version of Rust installed.\n- **Node.js** (Optional): Required if you are building a frontend with Leptos.\n- **MontRS CLI**: Install our command-line tool.\n\n```bash\ncargo install --path packages/cli\n```\n\n## ðŸš€ Creating Your First Project\n\nUse the `new` command to scaffold a project from a template.\n\n```bash\nmontrs new my-awesome-app\ncd my-awesome-app\n```\n\n## ðŸ—\u{fe0f} Project Structure\n\nA typical MontRS project looks like this:\n\n- `src/`: Your application source code.\n  - `main.rs`: Entry point.\n  - `plates/`: Your business logic organized into plates.\n- `montrs.toml`: Framework and task configuration.\n- `.agent/`: (Auto-generated) agent-readable project specifications.\n\n## ðŸƒ Running the App\n\nStart the development server with hot-reloading:\n\n```bash\nmontrs serve\n```\n\nYour app will be available at `http://localhost:3000`.\n\n## ðŸ¤– Agent-first development\n\nMontRS is designed to work with agents. Every time you run a CLI command, it updates `.agent/agent.json`. This file gives your agent coding partner a perfect understanding of your project's routes, schemas, and state.\n\n## ðŸ› \u{fe0f} Troubleshooting\n\n### 1. `montrs: command not found`\nEnsure that your Cargo binary directory is in your `PATH`. On most systems, this is `~/.cargo/bin`.\n\n### 2. Compilation Errors in `view!` Macros\nThe `view!` macro is very strict about HTML syntax. If you get a cryptic error, try running `montrs fmt` to see if it can identify a malformed tag or missing closing brace.\n\n### 3. `.agent` Folder Not Found\n\nThe `.agent` folder is created the first time you run `montrs serve`, `montrs build`, or `montrs spec`. If it's missing, try running `montrs spec` manually.\n\n---\n\n## ðŸ“š Next Steps\n\n- [The Golden Path](golden-path.md): Learn the best practices for building with MontRS.\n- [Router & Plates](router.md): Deep dive into our data-first architecture.\n- [Testing](testing.md): Write your first deterministic test.\n",
        "packages/fmt/docs/invariants.md": "# Formatter Package Invariants\n\n## 1. Responsibility\n`montrs-fmt` ensures a consistent, comment-preserving code style across the MontRS ecosystem, with special support for `view!` macros.\n\n## 2. Invariants\n- **Comment Preservation**: The formatter MUST NOT strip non-doc comments. Preserving developer intent is a priority over \"perfect\" whitespace.\n- **Logical Purity**: The formatter MUST NOT change the logical structure or behavior of the code. It is strictly a whitespace and layout tool.\n- **Idempotency**: Formatting a file multiple times with the same configuration must result in zero changes after the first pass.\n- **The Cascade of Truth**: Configuration must follow the hierarchical resolution (Workspace -> Project -> File) defined in the \"Cascade of Truth\".\n\n## 3. Boundary Definitions\n- **In-Scope**: Rust code formatting, `view!` macro (RSTML) formatting, comment handling.\n- **Out-of-Scope**: Linting, code analysis, auto-fixing of logic errors.\n\n## 4. Agent Guidelines\n- When generating code, you can rely on `montrs-fmt` to clean up the layout, but you must provide the comments yourself.\n- If a formatting error occurs, check the `FormatError` for specific `AgentError` metadata.\n",
        "packages/test/docs/invariants.md": "# Test Package Invariants\n\n## 1. Responsibility\n`montrs-test` provides the infrastructure for deterministic unit, integration, and e2e testing.\n\n## 2. Invariants\n- **Determinism**: Tests must be reproducible. Any non-deterministic behavior (time, random) must be mockable via `TestRuntime`.\n- **Isolation**: Tests should not leak state between runs.\n- **Agent-Verifiable**: Testing utilities should provide clear, machine-readable output for agents to verify their own changes.\n\n## 3. Boundary Definitions\n- **In-Scope**: Mocking traits, test runners, assertion libraries, e2e orchestration.\n- **Out-of-Scope**: Implementation of business logic being tested.\n",
        "architecture": "\n# MontRS Architecture Guide\nMontRS is a trait-driven, deterministic web framework built on Leptos 0.8.\n\n## Core Concepts\n- **AppSpec**: The single source of truth for the application blueprint.\n- **Plate**: A unit of composition (Auth, Blog, etc.) that registers unified routes.\n- **Unified Route**: A single struct implementing `Route` that unifies Params, Loader, Action, and View.\n- **Loaders**: Read-only, idempotent data fetching.\n- **Actions**: State-changing mutations.\n\n## How to build a plate\n1. Implement the `Plate` trait.\n2. Define explicit dependencies using the `dependencies()` method if your plate requires other plates to be initialized first.\n3. Define your `Route` implementation (which includes its `Loader`, `Action`, and `View`).\n4. Register the route in `register_routes` using `router.register(MyRoute)`.\n",
        "docs/agent\\mcp-setup.md": "# MCP Setup & Access Guide\n\nThe MontRS MCP (Model Context Protocol) server enables deep integration between your AI agents and the MontRS framework. This guide covers how to set up the server and grant agents access.\n\n## ðŸš€ Setting Up the Server\n\nThe MCP server is built into the `montrs` CLI.\n\n### 1. Ensure CLI is Installed\n```bash\ncargo install --path packages/cli --bin montrs --force\n```\n\n### 2. Start the Server\nThe server communicates via standard input/output (stdio), which is the standard for MCP.\n```bash\nmontrs mcp serve\n```\n\n## ðŸ”— Connecting Agents\n\nDepending on your agent environment, follow the steps below to connect.\n\n### For Trae / Cursor / Antigravity\nTo let the built-in IDE agent access MontRS tools:\n\n1.  Open your IDE settings.\n2.  Navigate to **MCP Servers** or **Tools**.\n3.  Add a new **Stdio** server:\n    -   **Name**: `MontRS`\n    -   **Command**: `montrs`\n    -   **Arguments**: `[\"mcp\", \"serve\"]`\n\n### For Custom Agents (Python/Node)\nIf you are building your own agent, use an MCP client library to spawn the `montrs mcp serve` process.\n\n**Example (Conceptual):**\n```python\nfrom mcp import Client, StdioClientTransport\n\nasync with Client(StdioClientTransport(\"montrs\", [\"mcp\", \"serve\"])) as client:\n    tools = await client.list_tools()\n    print(f\"Available tools: {tools}\")\n```\n\n## ðŸ› \u{fe0f} Available Tools\n\nOnce connected, your agent will have access to:\n\n| Tool | Description |\n| :--- | :--- |\n| `agent_check` | Validates project structure and invariants. |\n| `agent_doctor` | Checks framework health and agent-readability. |\n| `agent_diff` | Analyzes errors and provides fix instructions. |\n| `get_project_snapshot` | Returns full machine-readable project metadata. |\n| `agent_list_errors` | Returns structured list of active/resolved issues. |\n\n## ðŸ”’ Security & Permissions\n\nThe MCP server runs with the same permissions as the `montrs` CLI. It can:\n-   Read project files.\n-   Write to the `.agent` directory.\n-   Execute internal framework validation.\n\nIt **cannot** access files outside the current project root unless explicitly directed via path arguments.\n\n---\n*For more details on how to use these tools effectively, see the [Agentic CLI & MCP Workflows](agentic-workflows.md) guide.*\n",
        "docs/architecture\\packages.md": "# Package Boundaries & Responsibilities\n\nMontRS is organized as a modular workspace. Each package has a specific responsibility and strictly defined boundaries to ensure modularity and ease of maintenance.\n\n---\n\n## ðŸ“¦ `montrs-core`\n- **Responsibility**: Foundational traits (`Plate`, `Loader`, `Action`), routing engine, and `AppSpec` definition.\n- **Key Components**: `Router`, `Context`, `AppSpec`.\n- **Boundary**: It is strictly IO-agnostic. It defines the \"Grammar\" of how MontRS apps are built.\n- **When to modify**: When you need to change how routing works or add new fundamental capabilities to the framework.\n\n## ðŸ“¦ `montrs-cli`\n- **Responsibility**: Scaffolding (`new`), orchestration (`build`, `serve`), and task management.\n- **Key Components**: `Config`, `TaskRunner`, `ProjectScaffolder`.\n- **Boundary**: It is the \"Orchestrator.\" It depends on `core` and `agent` to understand the project state but does not contain business logic.\n- **When to modify**: When adding new CLI commands or improving the developer experience (DX).\n\n## ðŸ“¦ `montrs-agent`\n- **Responsibility**: Agent-first logic, snapshot generation (`agent.json`), and versioned error tracking.\n- **Key Components**: `AgentManager`, `ErrorRecord`, `ToolScanner`.\n- **Boundary**: Acts as a \"Sidecar.\" It scans the codebase (using `core` metadata) to produce machine-optimized context.\n- **When to modify**: When improving agent discoverability or changing the `agent.json` schema.\n\n## ðŸ“¦ `montrs-orm`\n- **Responsibility**: Database abstraction, SQL execution, and row mapping.\n- **Key Components**: `Database`, `Transaction`, `FromRow`.\n- **Boundary**: Handles all persistent data interactions. It provides a unified API that abstracts away the specific database driver (SQLite/Postgres).\n- **When to modify**: When adding support for a new database backend or improving the query builder.\n\n## ðŸ“¦ `montrs-schema`\n- **Responsibility**: Declarative validation and metadata generation via proc-macros.\n- **Key Components**: `#[derive(Schema)]`, `Validator`.\n- **Boundary**: Defines the \"Contract\" for data structures. It is used by both `core` (for routing) and `orm` (for mapping).\n- **When to modify**: When adding new validation rules or expanding metadata capture.\n\n## ðŸ“¦ `montrs-test`\n- **Responsibility**: Deterministic test runtime, fixtures, and E2E drivers.\n- **Key Components**: `TestRuntime`, `FixtureManager`.\n- **Boundary**: Provides the \"Validation Infrastructure.\" It allows testing of `Loader` and `Action` logic without needing a real network or database.\n- **When to modify**: When improving the testability of the framework or adding new mocking capabilities.\n\n---\n\n## How Packages Interact\n\nEvery package in the workspace maintains its own **[Local Invariants](file:///packages/*/docs/invariants.md)**. These documents define the specific \"rules of engagement\" and architectural boundaries for that package, providing immediate context for both human contributors and AI agents.\n\nMontRS follows a **Dependency Inversion** pattern. `montrs-core` defines the traits, and other packages (like `orm` or `schema`) provide implementations or tools that work with those traits.\n\n1.  **CLI** reads **Config** and **Core** to understand the app.\n2.  **Core** uses **Schema** to validate data at the boundaries.\n3.  **Plates** use **ORM** to persist data.\n4.  **Agent** scans everything to produce the **Spec Snapshot**.\n\n---\n\n## ðŸ› \u{fe0f} Adding New Packages\n\nIf you are a contributor looking to add a new package to the MontRS workspace, you **must** follow the guidelines in the **[Packages Contribution Guide](../community/packages-contribution.md)**. \n\nKey requirements include:\n- Defining clear boundaries.\n- Ensuring Agent-first compatibility.\n- Updating this document with the new package's responsibility.\n",
        "packages/agent/docs/agent-guide.md": "# Agent Usage Guide for montrs-agent\n\nThis document explains how agents should interact with the `montrs-agent` package and the files it generates.\n\n## The `.agent` Super Folder\n\nThe root `.agent` folder is the primary interface for agents. It contains:\n\n### `agent.json`\nThe project snapshot. It includes:\n- `structure`: A flat list of files in the project (excluding `.git`, `target`, etc.).\n- `plates`: High-level summaries of all MontRS plates found in the app.\n- `routes`: All registered loaders and actions with their input/output schemas.\n- `documentation_snippets`: Relevant guides (architecture, debugging) for quick context.\n\n### `tools.json`\nDefinitions of available CLI tools as function calls. Agents should use these to execute commands on behalf of the user.\n\n### `errorfiles/`\nA versioned repository of errors.\n- `v1/`, `v2/`, etc.: Directories representing the version of the error record.\n- `<error-id>.json`: A structured record of a specific error.\n\n## Error Handling Flow\n\nWhen an agent encounters an error (e.g., a build failure reported by the CLI):\n\n1. **Read the Error**: Look for the latest entry in `.agent/errorfiles/`.\n2. **Analyze Context**: The `detail` field provides the file, line, column, and code context.\n3. **Check History**: If the error has a history, look at previous versions to see if similar fixes were attempted.\n4. **Propose Fix**: Based on the `agent_metadata` (if available) and the code context, propose a fix.\n5. **Verify**: Run the build/test command again.\n6. **Record Resolution**: Once fixed, the CLI will call `resolve_error` to create a new version with the diff.\n\n## Best Practices for Agents\n\n- **Prefer `agent.json` over scanning the whole disk**: It's faster and contains pre-filtered information.\n- **Use the `subsystem` metadata**: When an error occurs, the `subsystem` field in `AgentError` metadata helps pinpoint which part of the framework is complaining.\n- **Leverage `suggested_fixes`**: These are human-authored hints specifically for resolving common issues in that subsystem.\n",
        "docs/tooling\\tasks.md": "# Custom Tasks and Automation\n\nMontRS provides a built-in task runner that replaces complex `Makefile`s or shell scripts. Tasks are defined in your `montrs.toml` file and can be executed via the CLI.\n\n## ðŸ“ Defining Tasks\n\nAdd a `[tasks]` section to your `montrs.toml`:\n\n```toml\n[tasks]\ndb-migrate = \"sqlx migrate run\"\ndb-seed = \"cargo run --bin seed\"\npre-commit = [\"montrs fmt\", \"montrs test\"]\n```\n\n## ðŸƒ Running Tasks\n\nUse the `run` command followed by the task name:\n\n```bash\nmontrs run db-migrate\n```\n\n## ðŸ› \u{fe0f} Task Features\n\n- **String Tasks**: A simple shell command.\n- **Array Tasks**: A sequence of tasks or commands run in order.\n- **Environment Variables**: Tasks inherit the environment defined in `montrs.toml`.\n\n## ðŸ¤– Agents and Tasks\n\nAgents can discover available tasks by reading the `montrs.toml` file or checking the `tools` section of `agent.json`. This allows an agent to perform complex operations like:\n- \"Run the database migrations before starting the server.\"\n- \"Execute the pre-commit checks to ensure the code is valid.\"\n\n## ðŸ’¡ Best Practices\n\n1. **Self-Documenting Names**: Use descriptive names like `generate-assets` instead of `gen`.\n2. **Keep Tasks Atomic**: A task should do one thing well. Use array tasks to compose them.\n3. **Use MontRS Commands**: Prefer `montrs fmt` over `rustfmt` to ensure the project-specific formatting rules are applied.\n",
        "packages/cli/docs/agent-guide.md": "# Agent Guide: montrs-cli\n\nThis guide helps agents interact with the MontRS command-line interface.\n\n## Core Concepts\n\n### 1. Project Management\n- `montrs new <name>`: Scaffolds a new project.\n- `montrs build`: Compiles the project.\n- `montrs serve`: Starts the dev server with hot-reload.\n\n### 2. Agent-first commands\n- `montrs spec`: Generates an agent-readable snapshot of the project in `.agent/agent.json`. This is the primary way for an agent to \"see\" the project structure and routing.\n- **Auto-generation**: The CLI automatically updates `.agent/agent.json` and `.agent/tools.json` on almost every interaction.\n\n### 3. Diagnostics and Debugging\n- If a command fails, the CLI generates a versioned error record in `.agent/errorfiles/vN/<id>.json`.\n- Agents should read these files to understand the context and suggested fixes.\n\n## Agent Usage Patterns\n\n### Getting a Project Overview\nBefore making changes, always suggest running `montrs spec` or reading `.agent/agent.json` to understand the current state.\n\n### Resolving Errors\nWhen a build fails, look for the latest entry in `.agent/errorfiles/`. It contains:\n- `error_code`: A stable ID for the error type.\n- `explanation`: Why it failed.\n- `suggested_fixes`: Actionable steps to fix it.\n- `rustc_error`: The raw compiler output if applicable.\n\n### Using Tools\nRefer to `.agent/tools.json` for a list of available tools (functions) provided by the MontRS ecosystem.\n",
        "workflows/adding-features": "# Workflow: Adding New Features\r\n\r\nThis guide defines the \"Golden Path\" for adding functionality to an app or extending the framework.\r\n\r\n---\r\n\r\n## ðŸ“± For Application Developers\r\n\r\n1.  **Contextualize**: Read the `docs/invariants.md` of the MontRS framework packages you are utilizing. These define the \"rules of engagement\" for using the framework's features correctly.\r\n2.  **Define Schema**: Create input/output structs with `#[derive(Schema)]`.\r\n2.  **Generate Boilerplate**:\r\n    -   Run `montrs generate plate <name>` for new features.\r\n    -   Run `montrs generate route <path> --plate <name>` for new endpoints.\r\n3.  **Implement Unified Route**: \r\n    -   The CLI generates `RouteLoader`, `RouteAction`, and `RouteView`.\r\n    -   Implement the business logic in the `load` and `act` methods.\r\n4.  **Register**:\r\n    -   Add modules to `mod.rs` as instructed by the CLI.\r\n    -   Register the plate in `main.rs` and the route in `Plate::register_routes`.\r\n5.  **Annotate**: Implement `description()` on Loaders and Actions for agent discovery.\r\n6.  **Verify**: Run `montrs spec` and `montrs agent check`.\r\n\r\n---\r\n\r\n## ðŸ—\u{fe0f} For Framework Contributors\r\n\r\n1.  **Invariants Check**: Read `packages/<target>/docs/invariants.md` to understand the internal architectural rules and boundary constraints of the framework package you are modifying.\r\n2.  **Trait Definition**: Define new core traits in `packages/core`.\r\n2.  **Implementation**: Provide default or specialized implementations in relevant packages.\r\n3.  **Macro Support**: If the feature requires automation, update `packages/schema` (procedural macros).\r\n4.  **CLI Integration**: Update `montrs generate` commands in `packages/cli` if the feature requires boilerplate.\r\n5.  **Agent Visibility**: \r\n    -   Update `packages/agent` to collect metadata for the new feature.\r\n    -   Add `@agent-tool` to the new implementation.\r\n6.  **Template Update**: Add an example of the feature to `templates/todo`.\r\n7.  **Final Audit**: Run `montrs spec` and `agent doctor`.\r\n\r\n---\r\n\r\n## ðŸ¤– Agent Instructions (MCP)\r\n-   **Step 1**: Read the relevant framework `docs/invariants.md` before proposing changes to ensure you are using the framework's features as intended.\r\n-   **Step 2**: Use `montrs generate` tools whenever possible to ensure architectural consistency.\r\n-   **Step 3**: Follow the **Golden Path** (Schema -> Generation -> Implementation -> Registration).\r\n-   **Step 4**: Always add `description()` to Loaders and Actions.\r\n-   **Step 5**: `agent_check({})` to verify compliance.\r\n",
        "docs/getting-started\\first-30-minutes.md": "# First 30 Minutes with MontRS\r\n\r\nWelcome! This guide is designed to take you from \"What is this?\" to \"I've built something\" in exactly half an hour. We'll focus on the core concepts and the \"Golden Path\" of development.\r\n\r\n---\r\n\r\n## 1. What Is MontRS? (2â€“3 minutes)\r\n\r\nMontRS is a Rust-native, trait-driven web framework built for teams that value **compile-time correctness**, **explicit boundaries**, and **deterministic execution**. It exists to solve the problem of \"architectural drift\"â€”where large apps become hard to reason about over time.\r\n\r\n**MontRS is great for:**\r\n- Complex web applications with deep data requirements.\r\n- Systems that need to be \"Agent-First\" (easily understood by agents).\r\n- Projects where testing and reliability are non-negotiable.\r\n\r\n**MontRS intentionally avoids:**\r\n- Implicit \"magic\" (like global side effects or hidden discovery).\r\n- Overly complex macros for business logic.\r\n- Tight coupling between the UI and the data layer.\r\n\r\n**Targets:** You can currently target **Web (WASM)** and **Native Desktop/Server** environments.\r\n\r\n---\r\n\r\n## 2. The MontRS Mental Model (5 minutes)\r\n\r\nTo build effectively with MontRS, you only need to understand four core concepts:\r\n\r\n1.  **Signals**: Fine-grained reactivity. Instead of re-rendering everything, MontRS updates only the specific parts of the UI that change when a \"Signal\" value is updated.\r\n2.  **Plates**: The unit of organization. Your app is a collection of independent plates (think tectonic plates) that register their own routes and logic.\r\n3.  **Unified Routes**: The boundaries of your app. A single struct that unifies parameters, data loading (GET), state changes (Mutations), and the visual UI.\r\n4.  **AppSpec**: A machine-readable \"blueprint\" of your entire app. It's how MontRS (and agents) knows exactly what your app can do without running it.\r\n\r\n---\r\n\r\n## 3. Create Your First App (5 minutes)\r\n\r\nFirst, install the CLI if you haven't already:\r\n```bash\r\ncargo install --path packages/cli\r\n```\r\n\r\nNow, scaffold a new project:\r\n```bash\r\nmontrs new my-app\r\ncd my-app\r\n```\r\n\r\n### The Generated Structure\r\n-   `src/main.rs`: The entry point where your app and plates are initialized.\r\n-   `src/plates/`: This is where your business logic lives.\r\n-   `montrs.toml`: Your project configuration.\r\n-   `.agent/`: (Auto-generated) Contains the `agent.json` specification for agent context.\r\n\r\nTypically, you'll spend 90% of your time in `src/plates/`.\r\n\r\n---\r\n\r\n## 4. Build Something Small but Real (10 minutes)\r\n\r\nLet's build a simple **Counter with Persistence**. We want a button that increments a number and saves it to a (simulated) database.\r\n\r\n### Step 1: Define the Schema\r\nIn MontRS, we always start with the data shape.\r\n```rust\r\n#[derive(Schema, Serialize, Deserialize)]\r\npub struct CounterState {\r\n    pub count: i32,\r\n}\r\n```\r\n\r\n### Step 2: Implement the Unified Route\r\nIn MontRS, a route bundles everything together.\r\n\r\n```rust\r\npub struct CounterRoute;\r\n\r\nimpl Route<AppConfig> for CounterRoute {\r\n    type Params = EmptyParams;\r\n    type Loader = GetCounterLoader;\r\n    type Action = IncrementAction;\r\n    type View = CounterView;\r\n\r\n    fn path() -> &'static str { \"/counter\" }\r\n    fn loader(&self) -> Self::Loader { GetCounterLoader }\r\n    fn action(&self) -> Self::Action { IncrementAction }\r\n    fn view(&self) -> Self::View { CounterView }\r\n}\r\n\r\n#[async_trait]\r\nimpl RouteLoader<EmptyParams, AppConfig> for GetCounterLoader {\r\n    type Output = CounterState;\r\n    async fn load(&self, ctx: RouteContext<'_, AppConfig>, _params: EmptyParams) -> Result<Self::Output, RouteError> {\r\n        // Fetch from database\r\n        Ok(CounterState { count: 0 }) \r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl RouteAction<EmptyParams, AppConfig> for IncrementAction {\r\n    type Input = CounterState;\r\n    type Output = CounterState;\r\n    async fn act(&self, ctx: RouteContext<'_, AppConfig>, _params: EmptyParams, input: Self::Input) -> Result<Self::Output, RouteError> {\r\n        Ok(CounterState { count: input.count + 1 })\r\n    }\r\n}\r\n```\r\n\r\n### Step 3: Use Signals in the View\r\nIn your component, you'd use a signal to track the local state:\r\n```rust\r\nlet (count, set_count) = create_signal(0);\r\n\r\nview! {\r\n    <div>\r\n        <p>\"Count is: \" {count}</p>\r\n        <button on:click=move |_| {\r\n            // The framework handles the Action call\r\n            set_count.update(|n| *n += 1);\r\n        }>\"Increment\"</button>\r\n    </div>\r\n}\r\n```\r\n\r\n**Why this way?** By bundling the *Read* (Loader), the *Write* (Action), and the *UI* (View) into a single `Route`, your code remains easy to test and agents can understand exactly how to interact with your counter.\r\n\r\n---\r\n\r\n## 5. How Data and Logic Flow (5 minutes)\r\n\r\nIn MontRS, data flows in a clear loop:\r\n\r\n1.  **UI** triggers an **Action**.\r\n2.  **Action** validates input via **Schema** and updates the **Database**.\r\n3.  **Router** re-triggers the **Loader**.\r\n4.  **Loader** provides new data to the **Signals**.\r\n5.  **Signals** update the **UI** atomically.\r\n\r\n```text\r\n[ UI ] --(Action)--> [ Validation ] --(Persistence)--> [ DB ]\r\n  ^                                                      |\r\n  |                                                      |\r\n[ Signal Update ] <---(New Data)--- [ Loader ] <---------+\r\n```\r\n\r\n**Invariant**: Business logic should live in **Actions** or dedicated **Services**, never directly in the UI components.\r\n\r\n---\r\n\r\n## 6. Testing & Confidence (2â€“3 minutes)\r\n\r\nBecause MontRS is deterministic, testing is straightforward. The `TestRuntime` allows you to boot your entire application \"spec\" in-process.\r\n\r\n```rust\r\n#[tokio::test]\r\nasync fn test_increment() {\r\n    let runtime = TestRuntime::new(MyPlate);\r\n    let result = runtime.call_route::<CounterRoute>(json!({ \"count\": 5 })).await;\r\n    assert_eq!(result.count, 6);\r\n}\r\n```\r\n\r\n**Why it matters**: You can test your entire backend logic without spinning up a real web server or complex infrastructure.\r\n\r\n---\r\n\r\n## 7. Where to Go Next\r\n\r\nYou've just scratched the surface of MontRS. Here is where to dive deeper:\r\n\r\n-   **[Core Architecture](architecture.md)**: Understand the \"Shape\" of the engine.\r\n-   **[The Golden Path](golden-path.md)**: Deep dive into idiomatic patterns.\r\n-   **[Routing & Plates](router.md)**: Master the Loader/Action pattern.\r\n-   **[Agent-First Development](../agent/agent-first.md)**: Learn how to let agents build for you.\r\n\r\nYou're now ready to build. Typically, developers start by exploring the `src/plates` folder in their new project. **Happy coding!**\r\n",
        "docs/community\\deployment.md": "# Deploying MontRS Applications\n\nMontRS applications are compiled to native binaries, making them easy to deploy across various environments, from traditional VPS to modern serverless platforms.\n\n## ðŸ“¦ Building for Production\n\nUse the `build` command with the `--release` flag:\n\n```bash\nmontrs build --release\n```\n\nThis will produce a single, optimized binary in `target/release/`.\n\n## ðŸ³ Docker Deployment\n\nA typical `Dockerfile` for a MontRS app:\n\n```dockerfile\nFROM rust:1.75 as builder\nWORKDIR /app\nCOPY . .\nRUN cargo install --path packages/cli\nRUN montrs build --release\n\nFROM debian:bookworm-slim\nCOPY --from=builder /app/target/release/my-app /usr/local/bin/my-app\nCMD [\"my-app\"]\n```\n\n## â˜\u{fe0f} Cloud Platforms\n\n### Railway / Render / Fly.io\nThese platforms can build your app using the `Dockerfile` above. Ensure you set the `PORT` and `DATABASE_URL` environment variables.\n\n### AWS / GCP / Azure\nDeploy the compiled binary to an EC2 instance, App Runner, or Cloud Run.\n\n## âš™\u{fe0f} Environment Configuration\n\nMontRS uses `dotenv` support and environment variable validation via `montrs-core`. Ensure your production environment has the necessary variables defined:\n\n```bash\nDATABASE_URL=postgres://...\nAPP_SECRET=...\nPORT=3000\n```\n\n## ðŸ¤– Agents and Deployment\n\nAgents can help generate CI/CD pipelines (e.g., GitHub Actions) by reading the `AppSpec` to understand the project's dependencies and build requirements.\n",
        "packages/core/docs/invariants.md": "# Core Package Invariants\n\n## 1. Responsibility\n`montrs-core` is the foundational engine of the framework. It defines the core traits, data structures, and contracts that all other packages must follow.\n\n## 2. Invariants\n- **Zero Local Dependencies**: This package must remain the root of the workspace. It cannot depend on any other package in `packages/`.\n- **Trait-Driven Design**: All framework capabilities (Plates, Routes, Config) must be defined via traits to ensure extensibility and agent-readiness.\n- **Mandatory Metadata**: Every public trait intended for application use MUST implement `.description()` and `.metadata()` methods.\n- **Structured Errors**: All error types must implement the `AgentError` trait, providing stable error codes and suggested fixes.\n- **IO Abstraction**: This package must NOT implement concrete IO (DB drivers, file system logic). It only defines the interfaces.\n\n## 3. Boundary Definitions\n- **In-Scope**: Trait definitions, routing logic, validation primitives, error trait definitions.\n- **Out-of-Scope**: UI rendering, DB implementations, CLI commands, agent inference.\n\n## 4. Agent Guidelines\n- When adding a new trait, ensure it is documented with `description()` so other agents can discover it.\n- Never introduce a dependency on another `montrs-*` package here.\n- Use the `validation.rs` primitives for any new data structures.\n",
        "docs/index.md": "# MontRS Documentation Index\r\n\r\nWelcome to the MontRS documentation. This folder contains deep-dive guides for both application developers and framework contributors, with a focus on our agent-first philosophy.\r\n\r\n## ðŸŽ¯ Audience Paths\r\n\r\n### For Application Developers\r\n- [First 30 Minutes](getting-started/first-30-minutes.md) - **Start here!** Your first onboarding experience.\r\n- [Introduction](getting-started/introduction.md) - Build your first MontRS app.\r\n- [The Golden Path](getting-started/golden-path.md) - Idiomatic MontRS development.\r\n- [Common Mistakes](guides/common-mistakes.md) - Avoid frequent pitfalls.\r\n- [Router](core/router.md) & [Plates](core/plates.md) - Understanding the Loader/Action pattern.\r\n- [Schema & Validation](core/schema.md) - Type-safe data handling.\r\n- [ORM Layer](orm/index.md) - Working with databases.\r\n- [ORM Backends](orm/backends.md) - Supported databases.\r\n- [Testing](testing/index.md) - Writing deterministic tests.\r\n- [Benchmarking](testing/benchmarking.md) - Measuring performance.\r\n- [Deployment](community/deployment.md) - Shipping to production.\r\n\r\n### For Framework Contributors\r\n- [Architecture Overview](architecture/overview.md) - The \"Shape\" of MontRS.\r\n- [AppSpec & Discovery](agent/appspec.md) - How the framework maps itself.\r\n- [Package Boundaries](architecture/packages.md) - Responsibility of each crate.\r\n- [Invariants & Philosophy](architecture/philosophy.md) - The rules we don't break.\r\n- [Agent-first design](agent/agent-first.md) - Principles of machine-readability.\r\n- [CLI Internals](tooling/cli.md) - Orchestration and task runners.\r\n- [Custom Tasks](tooling/tasks.md) - Automating workflows.\r\n- [Contributing Guide](community/contributing.md) - How to build MontRS.\r\n- [Packages Contribution](community/packages-contribution.md) - Guidelines for new framework packages.\r\n\r\n### For Agents\r\n- [**Agent Entry Point**](agent/index.md) - **Start here!** Unified operational framework.\r\n- [Agent Condensed Onboarding](agent/onboarding.md) - Core architectural knowledge.\r\n- [Agent Integration Guide](agent/agent-first.md) - Principles of machine-readability.\r\n- [Specialized Prompts](agent/prompt-usage.md) - Identity and constraints.\r\n- [Agentic CLI & Workflows](agent/agentic-workflows.md) - Mastering the agentic loop.\r\n- [MCP Setup & Access](agent/mcp-setup.md) - **New!** Connecting agents to the framework.\r\n- [Spec Snapshot](agent/spec.md) - Understanding `agent.json`.\r\n- [Error Handling Spec](core/errors.md) - Versioned error files and diffs.\r\n- [Metadata Standards](agent/metadata.md) - How we annotate code for you.\r\n\r\n---\r\n\r\n## ðŸ—\u{fe0f} Core Concepts\r\n\r\n- **Determinism**: Every part of MontRS is designed to be predictable and testable in isolation.\r\n- **Model-First**: We prioritize machine-readable metadata to enable agent-assisted development.\r\n- **Trait-Driven**: Interfaces are defined by traits, allowing for modular and swappable components.\r\n",
        "docs/testing\\index.md": "# Testing in MontRS\n\nMontRS provides a robust and comprehensive testing ecosystem designed to ensure your application is reliable, performant, and bug-free. The testing strategy is built on three pillars:\n\n1.  **Unit Testing**: Fast, isolated tests for individual functions and components.\n2.  **Integration Testing**: Tests that verify the interaction between multiple components (e.g., database, router, services).\n3.  **End-to-End (E2E) Testing**: Full-stack tests that simulate real user interactions in a browser environment.\n\nThis guide covers how to leverage the `montrs-test` package and the `montrs` CLI to implement these testing strategies.\n\n---\n\n## 1. Unit Testing\n\nUnit tests in MontRS follow standard Rust testing practices but are enhanced with the `montrs-test` library for better determinism and mocking.\n\n### Running Unit Tests\n\nYou can run unit tests using the standard Cargo command or the MontRS CLI:\n\n```bash\n# Standard Rust way\ncargo test\n\n# MontRS CLI (offers enhanced reporting)\nmontrs test\n```\n\nThe `montrs test` command supports generating JSON and JUnit reports for CI/CD integration:\n\n```bash\nmontrs test --report junit --output test-results.xml\n```\n\n### Writing Unit Tests\n\nMontRS provides a suite of production-grade utilities to improve Developer Experience (DevX), including fluent assertions, spies, and table-driven tests.\n\n#### Fluent Assertions\n\nInstead of standard `assert_eq!`, you can use `expect` for more readable tests.\n\n```rust\nuse montrs_test::unit::expect;\n\n#[test]\nfn test_fluent_assertions() {\n    expect(1 + 1).to_equal(2);\n    expect(vec![1, 2, 3]).to_contain(&2);\n    expect(true).to_be_true();\n    \n    // Negation\n    expect(1).not().to_equal(2);\n}\n```\n\n#### Spies and Mocks\n\nTrack function calls and verify interactions using `Spy` and `Mock`.\n\n```rust\nuse montrs_test::unit::Spy;\n\n#[test]\nfn test_spy() {\n    let spy = Spy::new();\n    \n    // Simulate a call\n    spy.record();\n    \n    expect(spy.called()).to_be_true();\n    expect(spy.call_count()).to_equal(1);\n}\n```\n\n#### Table-Driven Tests\n\nEasily define parameterized tests using the `table_test!` macro.\n\n```rust\nuse montrs_test::table_test;\n\nfn add(a: i32, b: i32) -> i32 { a + b }\n\ntable_test! {\n    name: test_addition,\n    func: add,\n    cases: [\n        (1, 1) => 2,\n        (2, 2) => 4,\n        (10, -5) => 5,\n    ]\n}\n```\n\n### Environment Mocking\n\nUse `montrs_test::integration::TestEnv` to mock environment variables and configurations without affecting your global environment.\n\n```rust\n#[cfg(test)]\nmod tests {\n    use montrs_test::integration::TestEnv;\n    use montrs_core::EnvConfig;\n\n    #[test]\n    fn test_config_loading() {\n        let env = TestEnv::new();\n        env.set(\"API_KEY\", \"test-secret-123\");\n\n        assert_eq!(env.get_var(\"API_KEY\").unwrap(), \"test-secret-123\");\n    }\n}\n```\n\n---\n\n## 2. Integration Testing\n\nIntegration tests verify that different parts of your application work together correctly. MontRS provides the `TestRuntime` to spin up a lightweight version of your app context.\n\n### Using Fixtures\n\nThe `Fixture` trait allows you to define reusable setup and teardown logic for your tests.\n\n```rust\nuse montrs_test::integration::{Fixture, run_fixture_test};\n\nstruct DbFixture {\n    conn_string: String,\n}\n\n#[async_trait::async_trait]\nimpl Fixture for DbFixture {\n    async fn setup() -> anyhow::Result<Self> {\n        // Spin up a test DB or use an in-memory one\n        Ok(Self { conn_string: \"sqlite::memory:\".to_string() })\n    }\n\n    async fn teardown(&mut self) -> anyhow::Result<()> {\n        // Cleanup logic\n        Ok(())\n    }\n}\n\n#[tokio::test]\nasync fn test_database_interaction() {\n    run_fixture_test::<DbFixture, _>(|fixture| async move {\n        assert_eq!(fixture.conn_string, \"sqlite::memory:\");\n        Ok(())\n    }).await.unwrap();\n}\n```\n\n---\n\n## 3. End-to-End (E2E) Testing\n\nMontRS provides a high-level E2E testing framework powered by Playwright (via the `playwright-rs` crate) and integrated into the `montrs` CLI.\n\n### Architecture\n\nThe E2E plate is built around the `MontrsDriver`, a wrapper around the Playwright browser automation library. It handles:\n- **Browser Lifecycle**: Automatically launching and closing browser instances (Chromium, Firefox, WebKit).\n- **Configuration**: Auto-detecting settings from `montrs.toml` or environment variables (`MONTRS_SITE_URL`, `LEPTOS_SITE_ADDR`).\n- **Orchestration**: When run via `montrs e2e`, it manages the full lifecycle of your application server (startup, readiness check, test execution, shutdown).\n\n### Setup\n\nTo enable E2E testing in your project, add `montrs-test` with the `e2e` feature to your `Cargo.toml` (usually in a dedicated `e2e` crate or the `[dev-dependencies]` section):\n\n```toml\n[dependencies]\nmontrs-test = { version = \"0.1.0\", features = [\"e2e\"] }\ntokio = { version = \"1\", features = [\"full\"] }\nanyhow = \"1.0\"\n```\n\n### Configuration\n\nYou can configure E2E settings in your `montrs.toml` file under the `[e2e]` section:\n\n```toml\n[e2e]\n# browser = \"chromium\"\n# headless = true\n# timeout = 30000 # Not yet supported in montrs.toml, use env var or default\nbase_url = \"http://localhost:3000\"\n```\n\nAlternatively, you can override these at runtime using environment variables:\n- `MONTRS_E2E_HEADLESS`: \"true\" or \"false\"\n- `MONTRS_E2E_BROWSER`: \"chromium\", \"firefox\", or \"webkit\"\n- `MONTRS_SITE_URL`: The base URL of the running application.\n\n### Writing E2E Tests\n\nE2E tests use the `MontrsDriver` to interact with your application.\n\n```rust\nuse montrs_test::e2e::MontrsDriver;\n\n#[tokio::test]\nasync fn test_home_page_loads() -> anyhow::Result<()> {\n    // 1. Initialize the driver (launches browser, connects to context)\n    let driver = MontrsDriver::new().await?;\n\n    // 2. Navigate to a route (automatically resolves against base_url)\n    driver.goto(\"/\").await?;\n\n    // 3. Perform assertions\n    let title = driver.page.title().await?;\n    assert!(title.contains(\"Welcome to MontRS\"));\n\n    // 4. Interact with elements\n    driver.page.click(\"text=Get Started\").await?;\n    assert!(driver.url().contains(\"/docs\"));\n\n    // 5. Cleanup\n    driver.close().await?;\n    \n    Ok(())\n}\n```\n\n### Advanced: Extending MontrsDriver with Plugins\n\nYou can extend the functionality of `MontrsDriver` by implementing the `MontrsPlugin` trait. This is useful for shared logic like authentication, custom logging, or complex setup routines.\n\n```rust\nuse montrs_test::e2e::{MontrsDriver, MontrsPlugin};\n\nstruct AuthPlugin {\n    username: String,\n}\n\n#[async_trait::async_trait]\nimpl MontrsPlugin for AuthPlugin {\n    async fn on_init(&self, driver: &MontrsDriver) -> anyhow::Result<()> {\n        // Automatically log in when the driver starts\n        driver.goto(\"/login\").await?;\n        driver.page.fill(\"input[name=username]\", &self.username).await?;\n        driver.page.click(\"button[type=submit]\").await?;\n        Ok(())\n    }\n}\n\n#[tokio::test]\nasync fn test_dashboard() -> anyhow::Result<()> {\n    let driver = MontrsDriver::new().await?;\n    \n    // Apply the plugin\n    driver.use_plugin(AuthPlugin { username: \"admin\".into() }).await?;\n    \n    // Now we are logged in\n    driver.goto(\"/dashboard\").await?;\n    assert!(driver.url().contains(\"/dashboard\"));\n    \n    driver.close().await?;\n    Ok(())\n}\n```\n\n### Running E2E Tests\n\n```bash\n# Run all E2E tests\nmontrs e2e\n\n# Run in a specific browser\nmontrs e2e --browser firefox\n\n# Run in headed mode (shows the browser)\nmontrs e2e --headless false\n```\n\nThe `montrs e2e` command automatically:\n1. Builds your application.\n2. Starts the development server.\n3. Runs the Playwright test suite against the live server.\n4. Shuts down the server upon completion.\n\nYou can also run them as standard Rust tests if you manage the server yourself:\n\n```bash\n# Start your server first\ncargo run & \n# Run tests\nMONTRS_SITE_URL=http://localhost:3000 cargo test --package e2e\n```\n\n---\n\n## CI/CD Integration\n\nMontRS testing tools are designed for CI environments.\n\n### GitHub Actions Example\n\n```yaml\nname: CI\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Install Rust\n        uses: dtolnay/rust-toolchain@stable\n        \n      - name: Install Playwright Dependencies\n        run: npx playwright install-deps\n        \n      - name: Run Unit Tests\n        run: montrs test --report junit --output unit-results.xml\n\n      - name: Run E2E Tests\n        run: montrs e2e --headless\n```\n",
        "docs/orm\\async.md": "# Async Patterns in MontRS ORM\n\nThe `montrs-orm` package is built from the ground up to be async-first, integrating seamlessly with the Tokio runtime and MontRS's data-first routing.\n\n## ðŸ§µ Non-Blocking Execution\n\nEvery database operation in MontRS is `async`. This ensures that your application remains responsive even under heavy load.\n\n```rust\n// Correct usage within a Loader or Action\nlet posts = ctx.db()\n    .query(\"SELECT * FROM posts\")\n    .fetch_all::<Post>()\n    .await?; // Must be awaited\n```\n\n## ðŸ”‹ Connection Pooling\n\nMontRS automatically manages a connection pool for you. When you call `ctx.db()`, you are requesting a connection from the pool.\n\n- **Automatic Cleanup**: Connections are returned to the pool once the request lifecycle is complete.\n- **Configurable Limits**: You can set the maximum number of connections in `montrs.toml`.\n\n## ðŸ”„ Transactions\n\nFor mutations that involve multiple steps, use our async transaction API:\n\n```rust\nctx.db().transaction(|tx| async move {\n    tx.execute(\"INSERT INTO orders ...\").await?;\n    tx.execute(\"UPDATE inventory ...\").await?;\n    Ok(())\n}).await?;\n```\n\n## ðŸ¤– Agents and Async Code\n\nWhen an agent generates database code for MontRS, it should always:\n1. Use `.await` on all `fetch` and `execute` calls.\n2. Handle `Result` types using the `?` operator to leverage the framework's `AgentError` integration.\n3. Keep database logic within `Loader` or `Action` implementations to ensure proper context access.\n",
        "docs/agent\\metadata.md": "# Metadata Standards for Agents\n\nTo ensure that MontRS remains machine-readable, we follow a strict set of metadata standards across the codebase.\n\n## ðŸ·\u{fe0f} The `@agent-tool` Marker\n\nAny function or struct that is intended to be used as a tool by an agent must be marked with the `@agent-tool` comment. This allows `montrs-agent` to automatically curate a `tools.json` file.\n\n```rust\n// @agent-tool: Generates a new project from a template.\npub fn scaffold_project(name: &str, template: &str) -> Result<()> { ... }\n```\n\n## ðŸ“ Trait Metadata\n\nCore traits (`Plate`, `Loader`, `Action`, `Limiter`, `Validate`) include a `description()` method. This should return a human-and-machine-readable summary of the component's purpose.\n\n```rust\nimpl Loader for MyLoader {\n    fn description(&self) -> Option<String> {\n        Some(\"Fetches the latest 10 posts from the database.\".to_string())\n    }\n}\n```\n\n## ðŸ§¬ Schema Definitions\n\nUse `#[derive(Schema)]` on all input and output structs. This provides the agent with the exact data shape and validation rules required for interaction.\n\n## ðŸ”„ The Curation Process\n\nHow does your code end up in the `agent.json` or `tools.json`?\n\n1.  **Scanning**: The `montrs-agent` scanner walks your source code.\n2.  **Extraction**: It looks for explicit markers like `@agent-tool` and implementations of traits like `Loader` or `AgentError`.\n3.  **Heuristics**: If a component lacks explicit metadata, the scanner uses heuristics (like reading the README in the same package) to infer its purpose.\n4.  **Serialization**: The extracted data is normalized into a standard JSON format and saved to the `.agent/` directory.\n\n---\n\n## ðŸ” Best Practices for Metadata\n\n-   **Be Descriptive**: Instead of `fn get_data()`, use `// @agent-tool: Fetches active user profiles from the primary database.`\n-   **Include Constraints**: Mention any rate limits or side effects in the description.\n-   **Keep it Up-to-Date**: If you change the behavior of a function, remember to update its `@agent-tool` comment or `description()` method.\n",
        "packages/orm/docs/agent-guide.md": "# Agent Guide: montrs-orm\n\nThis guide helps agents interact with the database layer of MontRS.\n\n## Core Concepts\n\n### 1. DbBackend Trait\nThe primary interface for database operations. It supports `execute` for writes and `query` for reads.\n- **SQLite**: Use `SqliteBackend` for local, file-based storage.\n- **Postgres**: Use `PostgresBackend` for production-grade networked databases.\n\n### 2. FromRow Trait\nAutomatically maps database rows to Rust structs.\n- **Agent Recommendation**: Always derive `FromRow` (or implement it) for your data models.\n\n### 3. ToSql Trait\nA bridge for passing parameters safely to different backends.\n\n## Agent Usage Patterns\n\n### Creating a Data Model\n```rust\n#[derive(FromRow)]\npub struct User {\n    pub id: i32,\n    pub name: String,\n}\n```\n\n### Executing Queries\nWhen asked to fetch data, use the `query` method and map the result to a struct using `FromRow`.\n```rust\nlet users: Vec<User> = db.query(\"SELECT * FROM users\", &[]).await?;\n```\n\n### Error Handling\n`DbError` implements `AgentError`. If a query fails, the `error_code` will indicate if it's a `DB_QUERY` syntax error or a `DB_CONNECTION` issue.\n",
        "workflows/fixing-errors": "# Workflow: Fixing Errors\r\n\r\nThis guide defines the standard procedures for identifying, analyzing, and resolving errors in both MontRS applications and the framework itself.\r\n\r\n---\r\n\r\n## ðŸ“± For Application Developers\r\n\r\nWhen your application has bugs, compilation errors, or structural violations:\r\n\r\n1.  **Identify**: Run `montrs agent list-errors --status Pending`.\r\n2.  **Contextualize**: \r\n    - Use `montrs agent diff <path_to_error_file>` (or the `agent_diff` MCP tool) to get a diagnostic report.\r\n    - **Read Framework Invariants**: Consult the `docs/invariants.md` for the framework packages you are utilizing to see if you have violated any usage rules.\r\n3.  **Analyze**: Use the diagnostic report to understand the root causes of the specific errors or bugs identified in Step 1.\r\n    -   Examine the error context.\r\n    -   Locate the root cause in the source code.\r\n4.  **Fix**: Apply the minimal change needed to resolve the issue.\r\n5.  **Validate**: Run `montrs agent check` to ensure no structural invariants were broken.\r\n6.  **Verify**: Run `cargo test` or `montrs test` to ensure functional correctness.\r\n7.  **Clean Up**: Once the error is resolved and verified, the agent will automatically mark it as `Fixed` in the next `montrs spec` run.\r\n\r\n---\r\n\r\n## ðŸ—\u{fe0f} For Framework Contributors\r\n\r\nWhen a framework package (e.g., `core`, `agent`, `cli`) has an error:\r\n\r\n1.  **Monitor**: Run `montrs agent list-errors` across the workspace.\r\n2.  **Isolate & Contextualize**: \r\n    - Identify which framework package owns the error.\r\n    - Read its `docs/invariants.md` to understand its internal architectural constraints.\r\n3.  **Trace**: Use `montrs agent diff` to see if the error is caused by a violation of framework-wide or package-specific internal invariants.\r\n4.  **Fix**: Apply the fix to the framework source. Ensure you maintain **Zero-Cost Abstractions** and **Determinism**.\r\n5.  **Audit**: Run `montrs agent doctor --package <package_name>` to verify framework health.\r\n6.  **Full Suite**: Run `cargo test --workspace` to ensure no regressions were introduced in other packages.\r\n7.  **Metadata Update**: Run `montrs spec` to ensure the fix is reflected in the machine-readable `agent.json`.\r\n\r\n---\r\n\r\n## ðŸ¤– Agent Instructions (MCP)\r\n-   **Step 1**: `agent_list_errors({\"status\": \"Pending\"})`\r\n-   **Step 2**: `agent_diff({\"path\": \"...\"})`\r\n-   **Step 3**: `get_project_snapshot({})` to find relevant code.\r\n-   **Step 4**: Apply fix.\r\n-   **Step 5**: `agent_check({})`\r\n",
        "docs/agent\\agentic-workflows.md": "# Agentic CLI & MCP Workflows\n\nMontRS provides a powerful suite of tools designed specifically for agentic development. This guide teaches agents how to leverage the CLI and Model Context Protocol (MCP) server to automate their work and ensure architectural compliance.\n\n## ðŸ¤– The Agentic Loop\n\nAgents should follow specific workflows based on the task at hand. See the detailed guides below:\n\n-   [**Fixing Errors**](workflows/fixing-errors.md): The self-correction loop for bugs and structural violations.\n-   [**New Projects & Packages**](workflows/new-projects.md): How to initialize and onboard new projects.\n-   [**Restructuring Projects**](workflows/restructuring.md): Safely refactoring and reorganizing code.\n-   [**Adding New Features**](workflows/adding-features.md): The \"Golden Path\" for extending functionality.\n\n## ðŸ› \u{fe0f} CLI Power Tools for Agents\n\n| Command | Purpose | When to Use |\n| :--- | :--- | :--- |\n| `montrs agent list-errors` | Lists all tracked errors and their status. | Start of every task. |\n| `montrs agent diff <path>` | Generates a diagnostic report for a specific error file. | When fixing a reported bug. |\n| `montrs agent check` | Validates the project against MontRS invariants. | After making code changes. |\n| `montrs agent doctor` | Runs a health check on the project/package. | When the environment feels unstable. |\n| `montrs spec` | Refreshes the machine-readable project snapshot. | Before analyzing project structure. |\n\n## ðŸ”Œ The MCP Advantage\n\nThe MCP server (`montrs mcp serve`) allows agents to interact with the framework as if it were a native set of functions. Instead of parsing CLI output, agents can call tools directly:\n\n-   **`get_project_snapshot`**: Returns the full JSON structure of the app.\n-   **`agent_list_errors`**: Returns structured error data for direct processing.\n-   **`agent_diff`**: Provides a step-by-step plan for fixing an error.\n-   **`list_router_structure`**: Deep-dives into the routing table.\n\n### Example Agentic Workflow (via MCP)\n1.  **Call** `agent_list_errors({\"status\": \"Pending\"})`.\n2.  **Pick** an error and **Call** `agent_diff({\"path\": \".agent/errorfiles/v1/ERR-001.json\"})`.\n3.  **Read** the suggested plan.\n4.  **Call** `get_project_snapshot({})` to find relevant files.\n5.  **Apply** the fix.\n6.  **Call** `agent_check({})` to verify.\n\n## ðŸ“ Best Practices for Agents\n\n-   **Refresh Often**: Always run `montrs spec` after significant structural changes.\n-   **Trust the Metadata**: Use `description()` and `schema` info from `agent.json` instead of guessing function signatures.\n-   **Incremental Fixes**: Use `agent check` after every file modification to catch regressions early.\n-   **Document Fixes**: When fixing an error, ensure your commit message or internal logs reference the Error ID (e.g., `ERR-AGENT-001`).\n\n---\n*By mastering these tools, you transform from a text-generator into a precise architectural engineer.*\n",
        "docs/community\\packages-contribution.md": "# Packages Contribution Guide\r\n\r\nThis guide is for contributors working **on** the MontRS framework itself. It defines the standards for creating, enhancing, and documenting packages within the MontRS workspace.\r\n\r\n---\r\n\r\n## ðŸ›¡\u{fe0f} The Core Principle: Agent-First by Design\r\n\r\nEvery package in MontRS must be machine-readable and predictable. When creating or updating a package, you must ensure:\r\n1.  **Deterministic Behavior**: Avoid hidden state. All IO and side effects should be injectable or mockable via `TestRuntime`.\r\n2.  **Trait-Based Interfaces**: Define core logic using traits. This allows `montrs-agent` to scan and understand the \"capabilities\" of your package.\r\n3.  **Self-Documenting Metadata**: Always implement `description()` and other metadata methods in your traits. This is how agents understand the \"Intent\" of your code.\r\n\r\n---\r\n\r\n## ðŸ—\u{fe0f} Creating a New Package\r\n\r\nBefore adding a new package to the workspace, ensure it has a clearly defined **Boundary**.\r\n\r\n### 1. File Structure\r\n- Place the new package in the `packages/` directory.\r\n- Follow the naming convention: `montrs-<name>`.\r\n- Include a `README.md` within the package folder explaining its specific role.\r\n- Include a `docs/invariants.md` file defining local architectural rules.\r\n\r\n### 2. Mandatory Documentation Updates\r\nWhen a new package is added, you **must** update the following global documentation:\r\n- **[packages.md](../architecture/packages.md)**: Add a new section describing the responsibility, key components, and boundaries of the package.\r\n- **[overview.md](../architecture/overview.md)**: Update the architecture diagram or description if the package changes the high-level flow.\r\n- **[index.md](../index.md)**: Link any new user-facing guides related to this package.\r\n\r\n---\r\n\r\n## ðŸ“ Documenting Improvements & Enhancements\r\n\r\nWhen you update, upgrade, or improve an existing package, you must document the change based on its impact.\r\n\r\n### 1. Internal Changes (Refactoring/Optimization)\r\n- Update the internal documentation within the code using Rustdoc (`///`).\r\n- Ensure any changes to internal traits are reflected in the package's local `README.md`.\r\n\r\n### 2. Feature Enhancements (New Capabilities)\r\n- **Code Comments**: Update trait descriptions to reflect new capabilities so that `montrs-agent` picks them up.\r\n- **User Guides**: If the enhancement changes how developers use MontRS, update the relevant guide in `docs/core/` or `docs/guides/`.\r\n- **Common Mistakes**: If the new feature introduces a potential pitfall, add it to **[common-mistakes.md](../guides/common-mistakes.md)**.\r\n\r\n### 3. Breaking Changes\r\n- Breaking changes must be documented in a \"Migration\" section in the package README.\r\n- Update the **[philosophy.md](../architecture/philosophy.md)** if the change affects a core framework invariant.\r\n\r\n---\r\n\r\n## ðŸ¤– Alignment with Agent-First Strategy\r\n\r\nContributors are responsible for maintaining the \"Agent Source of Truth\":\r\n- **Run `montrs spec`**: After making changes to traits or schemas, run the spec generator to ensure `.agent/agent.json` reflects your changes correctly.\r\n- **Versioned Errors**: If you add new error types, ensure they follow the stable error code format in `montrs-core` so they are machine-actionable.\r\n- **Metadata Standards**: Check **[metadata.md](../agent/metadata.md)** to ensure your new components provide the required info for AI coding partners.\r\n\r\n---\r\n\r\n## ðŸš€ Checklist for New Packages\r\n- [ ] Added to `Cargo.toml` workspace members.\r\n- [ ] Implements core metadata traits for agent-readiness.\r\n- [ ] Contains a local `README.md` with boundary definitions.\r\n- [ ] Contains `docs/invariants.md` with package-specific rules.\r\n- [ ] Updated **[packages.md](../architecture/packages.md)**.\r\n- [ ] Verified via `montrs spec` that the package is discoverable.\r\n- [ ] Added deterministic tests using `montrs-test`.\r\n",
        "docs/core\\plates.md": "# Plates: Composable Applications\n\nIn MontRS, a **Plate** is the primary unit of composition. Applications are built by combining multiple plates (often called \"reusable plates\" when they are shared components). The term \"Plate\" comes from tectonic platesâ€”the foundational structures that shift and interact to form the Nountain (Mont RS).\n\n## ðŸ§© What is a Plate?\n\nA `Plate` is a struct that implements the `Plate` trait. Its main job is to register routes (Unified Routes) with the `Router` and declare its architectural requirements.\n\n### ðŸ—\u{fe0f} Creating a Plate via CLI\n\nThe recommended way to create a plate is using the MontRS CLI:\n\n```bash\nmontrs generate plate <name>\n```\n\nThis will:\n1.  Create a new file `src/plates/<name>.rs` with the `Plate` boilerplate.\n2.  Provide instructions on how to register the plate in `main.rs`.\n\n### ðŸ—\u{fe0f} Manual Plate Definition\n\nIf you prefer to define a plate manually:\n\n```rust\npub struct AuthPlate;\n\nimpl Plate<MyConfig> for AuthPlate {\n    fn name(&self) -> &'static str { \"auth\" }\n    \n    // Explicitly declare dependencies for architectural integrity\n    fn dependencies(&self) -> Vec<&'static str> {\n        vec![\"db_plate\"]\n    }\n\n    fn register_routes(&self, router: &mut Router<MyConfig>) {\n        router.register(LoginRoute);\n        router.register(RegisterRoute);\n    }\n}\n```\n\n## ðŸ“¦ Reusable Plates\n\nReusable plates are designed to be shared across projects. Examples include:\n- `AuthPlate`: Handles user authentication and sessions.\n- `BlogPlate`: Provides a complete blogging engine.\n- `AdminPlate`: Generates an administrative dashboard.\n\n## ðŸ› \u{fe0f} Practical Example: Creating a Reusable Plate\n\nA reusable plate is just a standard plate designed for portability. Here is how you might structure one:\n\n```rust\n// packages/plates/blog/src/lib.rs\npub struct BlogPlate {\n    pub db_pool: Database,\n}\n\nimpl Plate<AppConfig> for BlogPlate {\n    fn name(&self) -> &'static str { \"BlogPlate\" }\n    \n    fn description(&self) -> &'static str {\n        \"A complete blogging system with posts and comments.\"\n    }\n\n    fn dependencies(&self) -> Vec<&'static str> {\n        vec![\"db\", \"auth\"] // Requires database and authentication\n    }\n\n    fn register_routes(&self, router: &mut Router<AppConfig>) {\n        router.register(ListPostsRoute::new(self.db_pool.clone()));\n        router.register(GetPostRoute::new(self.db_pool.clone()));\n    }\n}\n```\n\n---\n\n## ðŸ—\u{fe0f} Application Bootstrapping\n\nWhen a MontRS application starts, it follows these steps:\n\n1.  **Initialization**: The `App` instance is created, and core services (DB, Cache) are initialized.\n2.  **Plate Loading**: Every registered `Plate` is instantiated, often receiving service handles.\n3.  **Dependency Check**: `montrs agent check` (or internal validation) verifies that all plate dependencies are met and no cycles exist.\n4.  **Registration**: `register_routes` is called on each plate to build the global `Router`.\n5.  **Validation**: The `AppSpec` is generated and checked for route collisions or missing metadata.\n6.  **Runtime**: The server starts, and the `agent.json` spec is updated.\n\n---\n\n## ðŸ¤– Agents and Modularity\n\nBecause plates are explicit and trait-based, agents can easily understand and extend the system.\n\n### Common Agent Failure Modes\n- **Anti-Pattern**: Forgetting to register a plate in the main `App` entry point.\n  - *Fix*: Agents should check `main.rs` to ensure all newly created plates are added to the `App` builder.\n- **Anti-Pattern**: Circular dependencies between plates.\n  - *Fix*: Use the `dependencies()` method to declare requirements. The `montrs agent check` command will catch circularities early.\n- **Anti-Pattern**: Plates that are too large.\n  - *Fix*: If a plate has more than 10-15 routes, consider breaking it into smaller, more focused sub-plates.\n",
        "docs/core\\router.md": "# Routing in MontRS: The Unified Route Trait\n\nMontRS uses a \"Unified Route\" model that combines parameters, data fetching (`RouteLoader`), state changes (`RouteAction`), and visual representation (`RouteView`) into a single, type-safe unit.\n\n## ðŸ›£\u{fe0f} The Unified Route Trait\n\nInstead of disparate loaders and actions, MontRS defines a route as a struct implementing the `Route` trait. This provides a single source of truth for everything related to a specific URL path.\n\n```rust\npub trait Route<C: AppConfig>: Send + Sync + 'static {\n    type Params: RouteParams;\n    type Loader: RouteLoader<Self::Params, C>;\n    type Action: RouteAction<Self::Params, C>;\n    type View: RouteView;\n\n    fn path() -> &'static str;\n    fn loader(&self) -> Self::Loader;\n    fn action(&self) -> Self::Action;\n    fn view(&self) -> Self::View;\n}\n\n### ðŸ—\u{fe0f} Creating a Route via CLI\n\nThe recommended way to add a route to a plate is using the CLI:\n\n```bash\nmontrs generate route <path> --plate <plate_name>\n```\n\nThis generates a unified `Route` struct bundling `Params`, `Loader`, `Action`, and `View` into a single file, ensuring consistency and reducing boilerplate.\n\n### ðŸ—\u{fe0f} Manual Route Implementation\n\nIf you're not using the CLI, you must implement the `Route` trait:\n\n```rust\npub struct UserRoute;\n\nimpl Route<AppConfig> for UserRoute {\n    type Params = UserParams;\n    type Loader = UserLoader;\n    type Action = UserAction;\n    type View = UserView;\n\n    fn path() -> &'static str { \"/users/:id\" }\n    fn loader(&self) -> Self::Loader { UserLoader }\n    fn action(&self) -> Self::Action { UserAction }\n    fn view(&self) -> Self::View { UserView }\n}\n```\n\n## ðŸ“¥ RouteParams: Type-Safe Parameters\n\nEvery route defines its own parameter structure, which is automatically deserialized from the URL.\n\n```rust\n#[derive(Serialize, Deserialize)]\npub struct UserParams {\n    pub id: String,\n}\nimpl RouteParams for UserParams {}\n```\n\n## ðŸ“¥ RouteLoader: Fetching Data\n\nA `RouteLoader` is responsible for fetching the data needed for a route. It is read-only and idempotent.\n\n```rust\n#[async_trait]\nimpl RouteLoader<UserParams, MyConfig> for UserLoader {\n    type Output = User;\n    async fn load(&self, ctx: RouteContext<'_, MyConfig>, params: UserParams) -> Result<Self::Output, RouteError> {\n        let user = ctx.db().get_user(&params.id).await?;\n        Ok(user)\n    }\n}\n```\n\n## ðŸ“¤ RouteAction: State Changes\n\nA `RouteAction` handles mutations (POST, PUT, DELETE). It explicitly defines its input and output types.\n\n```rust\n#[async_trait]\nimpl RouteAction<UserParams, MyConfig> for UpdateUserAction {\n    type Input = UpdateUserInput;\n    type Output = User;\n    async fn act(&self, ctx: RouteContext<'_, MyConfig>, params: UserParams, input: Self::Input) -> Result<Self::Output, RouteError> {\n        let user = ctx.db().update_user(&params.id, input).await?;\n        Ok(user)\n    }\n}\n```\n\n## ðŸ–¼\u{fe0f} RouteView: Visual Representation\n\nThe `RouteView` defines how the route is rendered, typically using Leptos components.\n\n```rust\nimpl RouteView for UserView {\n    fn render(&self) -> impl IntoView {\n        view! { <UserPage /> }\n    }\n}\n```\n\n## ðŸ§© Registration in Plates\n\nRoutes are registered within a `Plate` using the `Router`.\n\n```rust\nimpl Plate<MyConfig> for UserPlate {\n    fn name(&self) -> &'static str { \"user\" }\n    \n    fn dependencies(&self) -> Vec<&'static str> {\n        vec![\"auth\"] // Depends on auth plate\n    }\n\n    fn register_routes(&self, router: &mut Router<MyConfig>) {\n        router.register(UserDetailRoute);\n        router.register(UserListRoute);\n    }\n}\n```\n\n## ðŸ”„ The Request Lifecycle\n\n1.  **Match**: The `Router` finds the matching route based on the URL path.\n2.  **Parse**: `RouteParams` are extracted and validated from the URL.\n3.  **Execute**: \n    - For GET: The `RouteLoader` is called.\n    - For Mutations: The `RouteAction` is called with the provided input.\n4.  **Render**: The `RouteView` is used to render the final UI (if applicable).\n\n## ðŸ¤– Agent-First Routing\n\nThe unified `Route` trait is designed specifically for agent discoverability. Because all parts of a route are linked through a single trait, an agent can:\n1.  **See the path** and parameters required.\n2.  **Understand the data** being fetched (Loader Output).\n3.  **Identify valid operations** (Action Input/Output).\n4.  **Explore the UI** (View).\n\nThis metadata is automatically exposed through the `AppSpec`, allowing agents to navigate and interact with your application with high confidence.\n",
        "docs/tooling\\fmt.md": "# Formatting in MontRS\n\nMontRS provides a built-in formatter via the `montrs fmt` command. It is designed to be fast, deterministic, and most importantly, respectful of your code's structure and comments.\n\n## The Formatter: `montrs-fmt`\n\nThe core of our formatting engine is `montrs-fmt`. It is built on top of `prettyplease`, but addresses several limitations commonly found in Rust formatters.\n\n### Key Innovations\n\n#### 1. Non-Doc Comment Preservation\nStandard Rust parsers like `syn` often discard non-doc comments (`//` and `/* ... */`) during the parsing process. This means that a formatter using these parsers will strip out your internal notes and explanations. \n\n`montrs-fmt` uses a \"Span-Gap\" algorithm to capture these comments before parsing and re-insert them into the formatted output, ensuring your internal documentation remains intact.\n\n#### 2. RSTML/View Macro Formatting\nMontRS uses `view!` macros for UI components. These macros contain HTML-like syntax that standard Rust formatters cannot handle well. `montrs-fmt` includes a specialized printer for RSTML that respects your formatting preferences for tags, attributes, and children.\n\n## Configuration: The Cascade of Truth\n\nWe employ a configuration strategy called the **Cascade of Truth**. This allows you to define your settings where they make the most sense for your workflow.\n\n### Resolution Order\n\n1.  **CLI Flags**: Highest priority. (e.g., `montrs fmt --check`)\n2.  **`montrs-fmt.toml`**: Project-specific formatter settings. Useful for dedicated formatting tools.\n3.  **`montrs.toml` ([fmt] section)**: Unified project settings. **Recommended for most projects.**\n4.  **Defaults**: Sensible fallback values.\n\n### Example Configuration\n\nYou can add this to your `montrs.toml`:\n\n```toml\n[fmt]\nmax_width = 100\ntab_spaces = 4\nindentation_style = \"Spaces\" # or \"Tabs\"\nnewline_style = \"Unix\" # or \"Windows\"\n\n[fmt.view]\n# How to handle empty tags: \"SelfClosing\" (<div />), \"NonSelfClosing\" (<div></div>), or \"Preserve\"\nclosing_tag_style = \"SelfClosing\"\n# When to use braces for attribute values\nattr_value_brace_style = \"WhenRequired\" # or \"Always\", \"Never\"\n```\n\n## View Macro Formatting\n\nMontRS uses a specialized printer for the `view!` macro to ensure that HTML-like syntax is formatted according to web standards while remaining valid Rust.\n\n### Formatting Rules\n\n1.  **Tag Indentation**: Children of an element are always indented by the configured `tab_spaces`.\n2.  **Attribute Alignment**: Attributes are typically placed on the same line as the opening tag unless they exceed `max_width`, in which case they are stacked vertically.\n3.  **Self-Closing Tags**: Tags like `<img>`, `<br>`, and `<input>` are automatically self-closed unless configured otherwise.\n4.  **Brace Style**: Attribute values like `class={my_class}` are formatted to maintain readability, with a preference for `WhenRequired` to reduce visual noise.\n\n### Example: Before and After\n\n**Original Code:**\n```rust\nview! { <div class=\"container\" id=\"main\"><h1 >Hello World</h1 ><p>This is a long paragraph that might need some better formatting if it were longer but for now it's just here.</p></div> }\n```\n\n**Formatted Output:**\n```rust\nview! {\n    <div class=\"container\" id=\"main\">\n        <h1>Hello World</h1>\n        <p>\n            This is a long paragraph that might need some better formatting if it were longer but\n            for now it's just here.\n        </p>\n    </div>\n}\n```\n\n---\n\n## Configuration Reference\n\nThe `[fmt]` section in your `montrs.toml` (or `montrs-fmt.toml`) supports the following options:\n\n| Option | Type | Default | Description |\n| :--- | :--- | :--- | :--- |\n| `max_width` | `usize` | `100` | Maximum line width before wrapping. |\n| `tab_spaces` | `usize` | `4` | Number of spaces per indentation level. |\n| `indentation_style` | `String` | `\"Spaces\"` | `\"Spaces\"` or `\"Tabs\"`. |\n| `newline_style` | `String` | `\"Unix\"` | `\"Unix\"` (\\n) or `\"Windows\"` (\\r\\n). |\n| `use_small_heuristics` | `bool` | `true` | Use shorter formatting for small items (e.g., single-line structs). |\n\n### View-Specific Options (`[fmt.view]`)\n\n| Option | Type | Default | Description |\n| :--- | :--- | :--- | :--- |\n| `closing_tag_style` | `String` | `\"SelfClosing\"` | `\"SelfClosing\"` (<div />), `\"NonSelfClosing\"` (<div></div>), or `\"Preserve\"`. |\n| `attr_value_brace_style` | `String` | `\"WhenRequired\"` | `\"WhenRequired\"`, `\"Always\"`, or `\"Never\"`. |\n\n---\n\n## Internal Architecture: The Span-Gap Algorithm\n\nFor contributors working on `montrs-fmt`, understanding the **Span-Gap Algorithm** is critical.\n\n### The Problem\nMost Rust formatters use the `syn` crate to parse code into an Abstract Syntax Tree (AST). However, `syn` is designed for procedural macros and ignores whitespace and non-doc comments. When the AST is printed back to source code, all internal comments are lost.\n\n### Our Solution\n1.  **Tokenization**: We use a custom tokenizer that identifies tokens (keywords, identifiers, symbols) and \"gaps\" (whitespace and comments).\n2.  **Span Mapping**: Every token in the AST is mapped to its original source span.\n3.  **Gap Capture**: Before formatting, we scan the source file and capture the content of every gap between token spans.\n4.  **Re-Injection**: During the printing phase, as we emit tokens from the AST, we check if there were any comments in the \"gap\" that preceded that token in the original source and re-emit them.\n\nThis ensures that `// TODO` or `/* internal note */` comments are never lost, even if the surrounding code is significantly restructured.\n\n## CLI Usage\n\n```bash\n# Format the entire project\nmontrs fmt\n\n# Check formatting in CI\nmontrs fmt --check\n\n# Format a specific directory\nmontrs fmt --path ./src/components\n```\n",
        "docs/architecture\\philosophy.md": "# Invariants & Philosophy\n\nMontRS is built on a set of core principles that guide every architectural decision. Understanding these will help you contribute to the framework and build better apps.\n\n## 1. Determinism by Default\n\nWe believe that a framework should be predictable. Given the same input and environment, a MontRS component should produce the same output. This makes testing, debugging, and agent-assisted development significantly more reliable.\n\n## 2. Specification-First (Model-First)\n\nA MontRS application is not just a collection of code; it is a living specification. The `AppSpec` is a first-class citizen, enabling a \"Model-First\" approach where agents can reason about the application's structure as effectively as a human developer.\n\n## 3. Trait-Driven Modularity\n\nWe prefer traits over macros for defining interfaces. This makes boundaries explicit, improves compile-time checks, and allows for easy swapping of components (e.g., changing a database backend or a logger).\n\n## 4. SQL-Centric Persistence\n\nWhile we provide an ORM, we don't hide SQL. We believe SQL is the most powerful and standardized way to interact with relational data. Our ORM focuses on making SQL safe and ergonomic in Rust.\n\n## 5. Explicit Boundaries\n\nData entering or leaving the application must be validated. The `montrs-schema` package ensures that boundaries between the frontend, backend, and database are clearly defined and enforced.\n\n## 6. Agents as First-Class Users\n\nWe design our tools and documentation not just for humans, but for agents. Structured metadata, versioned error files, and machine-readable snapshots are core features, not afterthoughts.\n\n## 7. Productive Explicitness (Scaffolded Explicit)\n\nWe avoid \"magic\" behaviors that are hard to trace. We prefer explicit registration and configuration over implicit discovery. However, explicitness should not mean \"tedious.\" \n\nMontRS follows the **Scaffolded Explicit** architecture:\n1. **Sketch**: Start with a single-file, explicit, and deterministic blueprint (`montrs sketch`).\n2. **Expand**: Grow into a full, structured workspace with explicit imports and manual registration (`montrs expand`).\n\nThis ensures that the developer (and the AI agent) always has a clear, readable source of truth while maintaining high iteration speed. All scaffolded code is production-ready and deterministic by construction.\n",
        "packages/agent/docs/design-system.md": "# MontRS Agent Messaging Design System\n\nThis document defines the structured way MontRS articulates information, documentation, and errors to agents.\n\n## 1. Tone and Articulation\n\n### Human-Facing Tone\n- **Professional & Helpful**: Concise instructions, clear warnings.\n- **Action-Oriented**: Focus on what the user needs to do next.\n\n### Agent-Facing Articulation (The \"Model-First\" Layer)\n- **Deterministic**: Use stable identifiers (error codes, trait names).\n- **Context-Rich**: Always include surrounding context (code snippets, file paths, line numbers).\n- **Remediation-Focused**: Provide \"suggested_fixes\" that are machine-actionable.\n\n## 2. Metadata Structure\n\nAll framework components (Plates, Loaders, Actions) must expose metadata via the following schema:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `description` | String | A high-level summary of the component's purpose. |\n| `input_schema` | JSON | (Optional) Validated schema for input data. |\n| `output_schema`| JSON | (Optional) Validated schema for output data. |\n| `tags` | Array | Categorical tags (e.g., \"auth\", \"db\", \"ui\"). |\n\n## 3. Error Articulation (AgentError)\n\nErrors are the primary communication channel during failure. Every `AgentError` must follow this structure:\n\n```json\n{\n  \"error_code\": \"STABLE_ID_UPPERCASE\",\n  \"explanation\": \"A detailed explanation of the cause.\",\n  \"suggested_fixes\": [\n    \"Step-by-step fix 1\",\n    \"Step-by-step fix 2\"\n  ],\n  \"subsystem\": \"package-name\",\n  \"rustc_error\": \"Optional raw compiler output\"\n}\n```\n\n## 4. Documentation Mapping\n\nDocumentation is curated into the `.agent/agent.json` snapshot using these priorities:\n1. **Explicit Metadata**: Values returned by `metadata()` methods.\n2. **Doc Comments**: Triple-slash `///` comments on public items.\n3. **Agent Guides**: Markdown files in `/docs/agent-guide.md`.\n4. **READMEs**: Key sections (Key Features, Usage).\n\n## 5. Learning from Resolution\n\nWhen an error is resolved, the CLI generates a diff. This diff is structured as:\n- **Base**: The error record and the state of the code at the time of failure.\n- **Fix**: The commit/changes that resolved the error.\n- **Lesson**: A summary of why the fix worked.\n\nAgents should prioritize these \"Resolution Diffs\" as the most reliable source of truth for debugging.\n",
        "packages/bench/docs/invariants.md": "# Bench Package Invariants\n\n## 1. Responsibility\n`montrs-bench` provides tools for measuring performance and ensuring no regressions in framework efficiency.\n\n## 2. Invariants\n- **Statistical Significance**: Benchmarking results must be based on a sufficient sample size and provide variance data.\n- **Environment Isolation**: Benchmarks should attempt to minimize noise from background processes.\n\n## 3. Boundary Definitions\n- **In-Scope**: Performance measurement, regression detection, profiling hooks.\n- **Out-of-Scope**: Code optimization logic.\n",
        "docs/agent\\workflows\\fixing-errors.md": "# Workflow: Fixing Errors\r\n\r\nThis guide defines the standard procedures for identifying, analyzing, and resolving errors in both MontRS applications and the framework itself.\r\n\r\n---\r\n\r\n## ðŸ“± For Application Developers\r\n\r\nWhen your application has bugs, compilation errors, or structural violations:\r\n\r\n1.  **Identify**: Run `montrs agent list-errors --status Pending`.\r\n2.  **Contextualize**: \r\n    - Use `montrs agent diff <path_to_error_file>` (or the `agent_diff` MCP tool) to get a diagnostic report.\r\n    - **Read Framework Invariants**: Consult the `docs/invariants.md` for the framework packages you are utilizing to see if you have violated any usage rules.\r\n3.  **Analyze**: Use the diagnostic report to understand the root causes of the specific errors or bugs identified in Step 1.\r\n    -   Examine the error context.\r\n    -   Locate the root cause in the source code.\r\n4.  **Fix**: Apply the minimal change needed to resolve the issue.\r\n5.  **Validate**: Run `montrs agent check` to ensure no structural invariants were broken.\r\n6.  **Verify**: Run `cargo test` or `montrs test` to ensure functional correctness.\r\n7.  **Clean Up**: Once the error is resolved and verified, the agent will automatically mark it as `Fixed` in the next `montrs spec` run.\r\n\r\n---\r\n\r\n## ðŸ—\u{fe0f} For Framework Contributors\r\n\r\nWhen a framework package (e.g., `core`, `agent`, `cli`) has an error:\r\n\r\n1.  **Monitor**: Run `montrs agent list-errors` across the workspace.\r\n2.  **Isolate & Contextualize**: \r\n    - Identify which framework package owns the error.\r\n    - Read its `docs/invariants.md` to understand its internal architectural constraints.\r\n3.  **Trace**: Use `montrs agent diff` to see if the error is caused by a violation of framework-wide or package-specific internal invariants.\r\n4.  **Fix**: Apply the fix to the framework source. Ensure you maintain **Zero-Cost Abstractions** and **Determinism**.\r\n5.  **Audit**: Run `montrs agent doctor --package <package_name>` to verify framework health.\r\n6.  **Full Suite**: Run `cargo test --workspace` to ensure no regressions were introduced in other packages.\r\n7.  **Metadata Update**: Run `montrs spec` to ensure the fix is reflected in the machine-readable `agent.json`.\r\n\r\n---\r\n\r\n## ðŸ¤– Agent Instructions (MCP)\r\n-   **Step 1**: `agent_list_errors({\"status\": \"Pending\"})`\r\n-   **Step 2**: `agent_diff({\"path\": \"...\"})`\r\n-   **Step 3**: `get_project_snapshot({})` to find relevant code.\r\n-   **Step 4**: Apply fix.\r\n-   **Step 5**: `agent_check({})`\r\n",
        "docs/testing\\benchmarking.md": "# Benchmarking in MontRS\r\n\r\nMontRS provides a professional-grade benchmarking ecosystem powered by the `montrs-bench` package. This allows you to measure the performance of your application and individual components with statistical rigor.\r\n\r\n## Overview\r\n\r\nThe benchmarking system is designed to be:\r\n- **Accurate**: Uses high-resolution timers and statistical analysis (mean, median, p95/p99, std dev).\r\n- **System-Aware**: Captures detailed system information (OS, CPU, RAM) for context.\r\n- **Integrated**: Works seamlessly with `montrs bench` and standard Rust tests.\r\n- **Exportable**: Supports JSON reporting for CI/CD integration.\r\n\r\n## Quick Start\r\n\r\n### 1. Add Dependency\r\n\r\nAdd `montrs-bench` to your `Cargo.toml` (usually in `[dev-dependencies]`):\r\n\r\n```toml\r\n[dev-dependencies]\r\nmontrs-bench = \"0.1.0\"\r\n```\r\n\r\n### 2. Write a Benchmark\r\n\r\nYou can define benchmarks using the `SimpleBench` wrapper or by implementing the `BenchCase` trait.\r\n\r\n```rust\r\nuse montrs_bench::{BenchRunner, SimpleBench, BenchConfig};\r\n\r\n#[tokio::main]\r\nasync fn main() -> anyhow::Result<()> {\r\n    let mut runner = BenchRunner::new();\r\n\r\n    runner.add(SimpleBench::new(\"vector_sort\", || async {\r\n        let mut v = vec![5, 2, 8, 1, 9];\r\n        v.sort();\r\n        Ok(())\r\n    }));\r\n\r\n    runner.run().await\r\n}\r\n```\r\n\r\n### 3. Run via CLI\r\n\r\nUse the `montrs bench` command to execute benchmarks.\r\n\r\n```bash\r\n# Run all benchmarks\r\nmontrs bench\r\n\r\n# Customize execution\r\nmontrs bench --iterations 1000 --warmup 50 --timeout 60\r\n\r\n# Filter specific benchmarks\r\nmontrs bench --filter \"vector_sort\"\r\n\r\n# Export report\r\nmontrs bench --json-output report.json\r\n```\r\n\r\n---\r\n\r\n## Native Benchmarking (`--simple`)\r\n\r\nMontRS supports a high-performance \"native\" mode for benchmarking standalone files, binaries, or `montrs.toml` configurations without the overhead of a full Cargo project.\r\n\r\nThis is ideal for quick testing, measuring script execution, or checking the size and load time of an AppSpec.\r\n\r\n### Features\r\n- **Zero Configuration**: No `Cargo.toml` required.\r\n- **File Size Reporting**: Automatically reports the target's size in MB and bytes.\r\n- **Smart Compilation**: Standalone `.rs` files are compiled with `rustc -O` and benchmarked.\r\n- **Direct Binary Execution**: Benchmarks existing executables directly.\r\n- **Config Profiling**: Measures `montrs.toml` (AppSpec) parsing and load speed.\r\n\r\n### Usage Examples\r\n\r\n```bash\r\n# Simple bench of a Rust source file\r\nmontrs bench --simple src/utils.rs\r\n\r\n# Bench an existing binary\r\nmontrs bench --simple ./target/release/my-app\r\n\r\n# Profile AppSpec load time\r\nmontrs bench --simple ./montrs.toml\r\n\r\n# Customize iterations and warmup for native mode\r\nmontrs bench --simple ./script.rs --iterations 50 --warmup 5\r\n```\r\n\r\n> **Note**: For `.rs` files, native mode uses `rustc` directly. If your file depends on external crates (other than `std`), you should use the standard project-based `montrs bench` instead.\r\n\r\n---\r\n\r\n## Writing Benchmarks\r\n\r\n### Closure-Based Benchmarks\r\n\r\nFor simple cases, use `SimpleBench`:\r\n\r\n```rust\r\nuse montrs_bench::SimpleBench;\r\n\r\nlet bench = SimpleBench::new(\"db_query\", || async {\r\n    db.query(\"SELECT 1\").await?;\r\n    Ok(())\r\n});\r\n```\r\n\r\n### Advanced Benchmarks (Trait-Based)\r\n\r\nFor more control over setup and teardown, implement `BenchCase`:\r\n\r\n```rust\r\nuse montrs_bench::BenchCase;\r\nuse async_trait::async_trait;\r\n\r\nstruct DbBenchmark {\r\n    db: Database,\r\n}\r\n\r\n#[async_trait]\r\nimpl BenchCase for DbBenchmark {\r\n    fn name(&self) -> &str {\r\n        \"complex_db_operation\"\r\n    }\r\n\r\n    async fn setup(&self) -> anyhow::Result<()> {\r\n        self.db.connect().await?;\r\n        self.db.seed_data().await?;\r\n        Ok(())\r\n    }\r\n\r\n    async fn run(&self) -> anyhow::Result<()> {\r\n        self.db.perform_heavy_calc().await?;\r\n        Ok(())\r\n    }\r\n\r\n    async fn teardown(&self) -> anyhow::Result<()> {\r\n        self.db.cleanup().await?;\r\n        Ok(())\r\n    }\r\n}\r\n```\r\n\r\n## Parameter-based Benchmarking (Substrate-Inspired)\r\n\r\nMontRS supports advanced parameter-based benchmarking, inspired by the **Substrate** blockchain framework. This allows you to measure how performance scales as inputs change (e.g., data size, number of elements, or iteration counts).\r\n\r\n### Parametric Benchmarking\r\n\r\nA parametric benchmark runs a workload across a range of values for a specific parameter. The runner then performs **Linear Regression** to calculate the **Slope** (time per unit of the parameter) and the **Intercept** (fixed overhead).\r\n\r\n#### 1. Defining a Parametric Benchmark\r\n\r\nUse `ParametricBench` to wrap a function that takes a `u32` parameter:\r\n\r\n```rust\r\nuse montrs_bench::{BenchRunner, ParametricBench, Parameter};\r\n\r\n#[tokio::main]\r\nasync fn main() -> anyhow::Result<()> {\r\n    let mut runner = BenchRunner::new();\r\n\r\n    // Define a parameter 'n' from 100 to 1000 with step 100\r\n    let param = Parameter::new(\"n\", 100..=1000, 100);\r\n\r\n    runner.add(ParametricBench::new(\"vector_fill\", param, |n| async move {\r\n        let mut v = Vec::with_capacity(n as usize);\r\n        for i in 0..n {\r\n            v.push(i);\r\n        }\r\n        Ok(())\r\n    }));\r\n\r\n    runner.run().await\r\n}\r\n```\r\n\r\n#### 2. Analyzing Results\r\n\r\nThe output will include the linear regression results:\r\n\r\n```text\r\nRunning vector_fill...\r\n  Parameter: n (10 values, 10 runs/val)\r\n  Mean:    54.2300 Âµs\r\n  Slope:   0.0542 ns/param  <-- Time scaling per unit of 'n'\r\n  Intercept: 1.2000 Âµs      <-- Base overhead\r\n```\r\n\r\n### Hardware Awareness\r\n\r\nBenchmarks in MontRS capture detailed hardware information to ensure results are reproducible and comparable across different machines. The report includes:\r\n- **CPU Frequency**: Useful for identifying thermal throttling.\r\n- **Physical vs Logical Cores**: Helps understand multi-threading performance.\r\n- **Memory Bandwidth context**: (Captured via system RAM specs).\r\n- **Binary Size**: Tracks the footprint of the benchmarked code.\r\n\r\n### Weight Generation and Usage\r\n \r\n MontRS enables a production-grade performance model through \"Weights\". A Weight is a mathematical abstraction of computational cost, composed of a **Base** (fixed overhead) and a **Slope** (cost per unit).\r\n \r\n #### Why Weights?\r\n \r\n Standard benchmarking gives you a snapshot (\"it took 5ms\"). Weights give you a **predictive model** (\"it takes 1ms + 10ns per byte\"). This turns benchmarking data into actionable application logic.\r\n \r\n **Key Use Cases:**\r\n \r\n 1. **Resource Budgeting & Quotas**: For SaaS/Cloud services, calculate the \"cost\" of a user request *before* executing it. If `cost > quota`, reject it immediately to prevent noisy neighbors.\r\n 2. **DoS Prevention**: In Wasm/eBPF runtimes, use weights to assign \"Gas\" costs to operations, preventing algorithmic complexity attacks (infinite loops or O(N^2) blowups).\r\n 3. **Deterministic Scheduling**: For Real-Time/IoT systems, use weights to calculate exactly how many items you can process within a fixed 10ms deadline.\r\n 4. **Performance Regression Tracking**: Track the `SLOPE_NS` over time in CI. A jump from 5ns to 50ns per item indicates an algorithmic regression ($O(N)$ -> $O(N^2)$?) that simple mean-time checks might miss on small datasets.\r\n 5. **Capacity Planning**: Mathematically prove cluster sizing. If peak traffic is 10k items/sec and slope is 100ns, you need exactly 1ms of CPU time/sec.\r\n \r\n #### Generating Weights\r\n \r\n You can generate a Rust file containing these constants directly from the CLI:\r\n \r\n ```bash\r\n # Generate weights from a benchmark run\r\nmontrs bench --generate-weights src/weights.rs\r\n ```\r\n \r\n This produces a file like:\r\n \r\n ```rust\r\n //! Autogenerated weights\r\n pub mod vector_fill {\r\n     pub const BASE_NS: f64 = 1200.0;\r\n     pub const SLOPE_NS: f64 = 0.054;\r\n     pub const WEIGHT: montrs_bench::Weight = montrs_bench::Weight::from_ns(1200, 0);\r\n }\r\n ```\r\n \r\n #### Using Weights in Application Code\r\n \r\n MontRS provides the `Weight` struct to make using these constants easy.\r\n \r\n ```rust\r\n use montrs_bench::Weight;\r\n \r\n // 1. Import generated weights\r\n mod weights { include!(\"weights.rs\"); }\r\n \r\n fn handle_request(input: Vec<u8>) -> Result<(), Error> {\r\n     // 2. Calculate cost before execution\r\n     let cost = weights::vector_fill::WEIGHT.calc(input.len() as u32);\r\n     \r\n     // 3. Enforce limits\r\n     if cost > MAX_ALLOWED_COST {\r\n         return Err(Error::QuotaExceeded);\r\n     }\r\n     \r\n     process(input);\r\n     Ok(())\r\n }\r\n ```\r\n\r\n---\r\n\r\n## Configuration\r\n\r\nYou can configure the benchmark runner programmatically or via CLI args.\r\n\r\n```rust\r\nuse montrs_bench::BenchConfig;\r\nuse std::time::Duration;\r\n\r\nlet config = BenchConfig {\r\n    iterations: 500,\r\n    warmup_iterations: 20,\r\n    duration: Some(Duration::from_secs(10)),\r\n    ..Default::default()\r\n};\r\n\r\nlet runner = BenchRunner::with_config(config);\r\n```\r\n\r\n## Reports\r\n\r\nThe CLI output provides a human-readable summary:\r\n\r\n```text\r\nRunning MontRS Benchmarks\r\nSystem: Windows (Intel(R) Core(TM) i9-14900K)\r\n---------------------------------------------------\r\nRunning vector_sort... Done\r\n  Mean:    1.2345 Âµs\r\n  Median:  1.2000 Âµs\r\n  StdDev:  0.0500 Âµs\r\n  Ops/sec: 810044.55\r\n---------------------------------------------------\r\n```\r\n\r\nThe JSON report (`--json-output`) contains detailed data for analysis:\r\n\r\n```json\r\n{\r\n  \"system\": {\r\n    \"os_name\": \"Windows\",\r\n    \"cpu_cores\": 24,\r\n    \"rust_version\": \"1.75.0\"\r\n  },\r\n  \"results\": {\r\n    \"vector_sort\": {\r\n      \"stats\": {\r\n        \"mean\": 0.0000012345,\r\n        \"p99\": 0.0000015000\r\n      },\r\n      \"iterations\": 100\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## Integration with `montrs-test`\r\n\r\nThe `montrs-test` package re-exports benchmarking utilities for convenience in unit tests.\r\n\r\n```rust\r\nuse montrs_test::unit::bench;\r\n\r\n#[tokio::test]\r\nasync fn test_perf() {\r\n    bench(\"quick_check\", 100, || async {\r\n        // ...\r\n    }).await;\r\n}\r\n```\r\n",
        "docs/agent\\prompt-usage.md": "# How to Use MontRS Specialized Agent Prompts\n\nThis guide explains how to use the specialized system prompts for MontRS agents. These prompts are designed to turn generic LLMs into expert partners for either building apps with MontRS or contributing to the framework itself.\n\n## ðŸ‘¥ Audience\n\n-   **Application Developers**: Use the [App Developer Prompt](app-developer-prompt.md) to build features, fix bugs, and architect your MontRS applications.\n-   **Framework Contributors**: Use the [Framework Contributor Prompt](framework-contributor-prompt.md) when working on the MontRS source code, adding new packages, or improving CLI tools.\n\n## ðŸš€ For Users (Humans)\n\n### 1. Choose the Right Prompt\n-   If you are building an app (e.g., using `montrs new`): Use the **App Developer Prompt**.\n-   If you are editing the MontRS workspace (e.g., in `packages/`): Use the **Framework Contributor Prompt**.\n\n### 2. Setting Up the Agent\nCopy the content of the selected prompt file and set it as the **System Prompt** (or \"Instructions\") in your AI chat interface, IDE (like Trae, Antigravity or Cursor), or custom agent configuration.\n\n### 3. Contextualizing the Session\nFor the best results, provide the agent with the latest project state:\n1.  Run `montrs spec` in your terminal.\n2.  Point the agent to the `.agent/agent.json` (or `agent.txt`) file.\n3.  If there are errors, show it the latest `errorfile.json` in `.agent/errorfiles/`.\n\n## ðŸ¤– For Agents (AI)\n\n### 1. Internalizing the Identity\nOnce you receive these prompts, you are no longer a general-purpose assistant. Your primary goal is to uphold the **MontRS Golden Path** and **Architectural Invariants**.\n\n### 2. Utilizing the .agent Folder\n-   **Always check `agent.json`**: This is your map of the project.\n-   **Respect `tools.json`**: Use the CLI tools described there instead of guessing commands.\n-   **Look for `@agent-tool`**: These markers indicate functions you are encouraged to use.\n\n### 3. Reporting and Correcting\n-   If you identify a violation of MontRS principles (e.g., global state), report it immediately to the user.\n-   Use the `agent check` and `agent doctor` tools (via MCP or CLI) to verify your own suggestions.\n\n## ðŸ› \u{fe0f} Integration with IDEs (Trae/Cursor)\n\nTo use these prompts effectively in your IDE:\n1.  Open the `.rules` or `.cursorrules` file in your project root.\n2.  Reference or paste the relevant prompt into that file.\n3.  This ensures every interaction with the IDE's agent is governed by MontRS principles.\n\n---\n*By using these specialized prompts, you ensure that your MontRS project remains clean, maintainable, and perfectly tuned for the future of agentic development.*\n",
        "docs/agent\\appspec.md": "# AppSpec: The Blueprint of a MontRS Application\r\n\r\nThe `AppSpec` is the central source of truth for a MontRS project. It is a serializable data structure that captures the \"Shape\" of the application, including its plates, routes, schemas, and metadata.\r\n\r\n## ðŸ” How Discovery Works\r\n\r\nMontRS uses a **heuristic discovery engine** to map your source code into an `AppSpec`. This happens in several phases:\r\n\r\n1.  **Static Analysis**: The CLI scans your `src/` directory for implementations of core traits (`Plate`, `Route`, `RouteLoader`, `RouteAction`).\r\n2.  **Metadata Extraction**: It invokes the `description()`, `path()`, and schema methods on these implementations.\r\n3.  **Dependency Mapping**: It identifies how plates are composed and which external plates are being used.\r\n4.  **Serialization**: The resulting graph is serialized into `.agent/agent.json` (for agent context) and used internally by the CLI to orchestrate the build.\r\n\r\n## ðŸ› \u{fe0f} The Structure of a Spec\r\n\r\nAn `AppSpec` contains:\r\n\r\n-   **Metadata**: Project name, version, and agent-specific instructions.\r\n-   **Plates**: A list of all registered plates and their internal configurations.\r\n-   **Routes**: A mapping of paths to **Unified Routes**, which bundle Params, Loaders, Actions, and Views.\r\n-   **Environment**: Required environment variables and their validation rules.\r\n\r\n## ðŸ¤– Why it matters for Agents\r\n\r\nFor an agent, the `AppSpec` is the **Project Manual**. Instead of grep-ing through thousands of lines of code to find where a route is defined, the agent can simply query the spec:\r\n\r\n```json\r\n{\r\n  \"path\": \"/api/users\",\r\n  \"name\": \"UserRoute\",\r\n  \"loader\": {\r\n    \"description\": \"Returns a paginated list of users\",\r\n    \"output_schema\": { ... }\r\n  },\r\n  \"action\": {\r\n    \"description\": \"Updates a user\",\r\n    \"input_schema\": { ... }\r\n  }\r\n}\r\n```\r\n\r\n## ðŸ”„ Refreshing the Spec\r\n\r\nWhenever you make structural changes to your code (adding a route, changing a schema), you should run:\r\n\r\n```bash\r\nmontrs spec\r\n```\r\n\r\nThis ensures that the `.agent/agent.json` file is in sync with your source code, providing the most accurate context for your agent coding partner.\r\n",
        "docs/agent\\index.md": "# ðŸ¤– MontRS Agent Entry Point\r\n\r\nWelcome to the unified command center for MontRS Agents. This document is the \"Map of Maps\"â€”it defines the operational framework for how you should interact with the codebase based on your current intent.\r\n\r\n---\r\n\r\n## ðŸ§­ Operational Framework: \"What are you doing?\"\r\n\r\nChoose your path based on the task at hand. Do not attempt to \"wing it\"â€”follow the established workflows to maintain architectural integrity.\r\n\r\n### 1. I am fixing a Bug or Error\r\n- **Goal**: Identify, diagnose, and resolve a failure (compilation, runtime, or architectural).\r\n- **Primary Guide**: [Workflow: Fixing Errors](workflows/fixing-errors.md)\r\n- **Key Tools**: `montrs agent list-errors`, `montrs agent diff`.\r\n\r\n### 2. I am adding a New Feature\r\n- **Goal**: Extend the application or framework with new capabilities.\r\n- **Primary Guide**: [Workflow: Adding Features](workflows/adding-features.md)\r\n- **Key Tools**: `montrs generate plate`, `montrs generate route`, `montrs spec`.\r\n\r\n### 3. I am starting a New Project\r\n- **Goal**: Scaffold a fresh MontRS application from scratch.\r\n- **Primary Guide**: [Workflow: New Projects](workflows/new-projects.md)\r\n- **Key Tools**: `montrs new`.\r\n\r\n### 4. I am restructuring or Refactoring\r\n- **Goal**: Move logic, split plates, or improve architectural health without changing behavior.\r\n- **Primary Guide**: [Workflow: Restructuring](workflows/restructuring.md)\r\n- **Key Tools**: `montrs agent check`.\r\n\r\n---\r\n\r\n## ðŸŽ­ System Prompts (Your Identity)\r\n\r\nYour behavior is governed by your specific role. Read these to understand your constraints and core identity:\r\n\r\n- **[App Developer Prompt](app-developer-prompt.md)**: For building applications *using* MontRS.\r\n- **[Framework Contributor Prompt](framework-contributor-prompt.md)**: For developing and maintaining the *framework itself*.\r\n\r\n---\r\n\r\n## ðŸ›¡\u{fe0f} Foundational Knowledge\r\n\r\nBefore performing any action, ensure you are grounded in these core principles:\r\n\r\n- **[Agent-First Philosophy](agent-first.md)**: Why we prioritize machine-readability.\r\n- **[Framework Invariants](onboarding.md)**: The rules you must never break.\r\n- **[Spec Snapshot (agent.json)](spec.md)**: How to read the project's current state.\r\n- **[Metadata Standards](metadata.md)**: How to annotate code for discovery.\r\n\r\n---\r\n\r\n## ðŸ”Œ Tooling & Integration\r\n\r\n- **[MCP Setup & Access](mcp-setup.md)**: How to connect your capabilities to the project.\r\n- **[Agentic CLI Guide](agentic-workflows.md)**: Mastering the command-line loop.\r\n",
        "docs/agent\\onboarding.md": "# MontRS: Agent-first condensed onboarding\n\nThis document is a technical specification for agents, agent-powered IDEs, and automated tools. It defines the core abstractions, invariants, and implementation patterns required to generate idiomatic, compilable MontRS code.\n\n---\n\n### 1. What MontRS Is (Agent Summary)\n\nMontRS is a modular, trait-driven Rust framework for building cross-platform applications. It enforces a strict separation between business logic (Loaders/Actions), state management (Signals), and platform-specific UI rendering. It uses a \"Specification-First\" approach where application structure is discoverable via metadata.\n\n- **Supported Targets**: Web (WASM), Mobile (iOS/Android via FFI/Bridge), Desktop (Native).\n- **Core Design Goals**: Determinism, modularity, agent-discoverability, zero-magic traits.\n- **Non-Goals**: Implicit global state, runtime reflection, direct UI-to-DB coupling.\n\n---\n\n### 2. Core Invariants (Non-Negotiable Rules)\n\n- **State Locality**: State must live in `Signals` or `Plates`. Never use global `static mut`.\n- **Explicit Mutation**: Mutation only happens inside `Actions` or via explicit `Signal::set()`.\n- **Side Effect Isolation**: Side effects (I/O, DB, Network) must be encapsulated in `Plates` and exposed via `Loaders` or `Actions`.\n- **Determinism**: Given the same input and state, a `Loader` must return the same output.\n- **Router Sovereignty**: The `Router` is the single source of truth for the application's functional surface area.\n\n---\n\n### 3. The Golden Path (Default Behavior)\n\n1. **Define Schema**: Create structs with `#[derive(Schema)]`.\n2. **Implement Logic**: Wrap logic in `Loader` (read) or `Action` (write).\n3. **Register Route**: Attach logic to a path in a `Plate`.\n4. **Expose Metadata**: Implement `description()` and `input_schema()` for agent discovery.\n\n**Flow Diagram:**\n`UI (View) -> Action (Mutation) -> Plate (Side Effect) -> DB/Store -> Loader (Read) -> Signal (Update) -> UI (Reactive)`\n\n---\n\n### 4. Routing Rules for Agents\n\n- **Loaders**: Read-only operations. Must implement `Loader<Input, Output>`. Never mutate state.\n- **Actions**: Write operations. Must implement `Action<Input, Output>`. Responsible for state changes.\n- **Composition**: Routes are registered in `Plate::register_routes(&mut router)`.\n- **Constraints**: No business logic in the `main` function. No direct DB calls in the UI layer.\n\n**Example Loader:**\n```rust\npub struct UserLoader;\nimpl Loader<UserId, UserProfile> for UserLoader {\n    fn load(&self, input: UserId) -> Result<UserProfile, Error> {\n        // Pure read logic\n    }\n}\n```\n\n**Example Action:**\n```rust\npub struct UpdateEmailAction;\nimpl Action<UpdateEmailInput, ()> for UpdateEmailAction {\n    fn call(&self, input: UpdateEmailInput) -> Result<(), Error> {\n        // Mutation logic + Side effects\n    }\n}\n```\n\n---\n\n### 5. State & Reactivity Rules\n\n- **Signals**: Always use `Signal<T>` for reactive state.\n- **Never Implicit**: No hidden observers. State changes must be triggered by explicit calls.\n- **Derived State**: Use `DerivedSignal` for values computed from other signals.\n- **Never Sync**: Never manually sync state between different signals; use the framework's reactive graph.\n\n---\n\n### 6. Plates & Side Effects\n\n- **Plates**: The unit of composition. They own their own services (DB pools, clients).\n- **Side Effects**: Always inject dependencies into Plates during initialization.\n- **Uncertainty**: If unsure where logic belongs, put it in a `Plate` service and expose it via an `Action`.\n\n---\n\n### 7. Testing & Determinism\n\n- **TestRuntime**: Use `TestRuntime` to mock environment variables, DB, and time.\n- **Predictability**: Avoid `SystemTime::now()` or random numbers without a seedable generator provided by the runtime.\n- **Testable Code**: Write logic that accepts traits instead of concrete implementations to allow mocking.\n\n---\n\n### 8. Common Agent Failure Modes\n\n- **Anti-Pattern**: Direct UI-to-Database access.\n  - *Fix*: Always go through a `Loader`.\n- **Anti-Pattern**: Business logic inside `register_routes`.\n  - *Fix*: Keep routes as thin mapping layers.\n- **Anti-Pattern**: Using `std::sync::RwLock` for app state.\n  - *Fix*: Use `Signal<T>` for reactivity.\n- **Anti-Pattern**: Forgetting `#[derive(Schema)]` on input/output types.\n  - *Fix*: Agents must ensure all transit types are Schema-ready.\n\n---\n\n### 9. Output Expectations\n\nBefore emitting code, the agent must verify:\n- [ ] All inputs/outputs derive `Schema`, `Serialize`, and `Deserialize`.\n- [ ] No side effects exist outside of `Plates` or `Actions`.\n- [ ] `Loaders` are strictly read-only.\n- [ ] Routes are registered via `Plate` traits.\n- [ ] No global mutable state is introduced.\n- [ ] Metadata methods (`description`, `tags`) are implemented for all traits.\n",
        "docs/orm\\index.md": "# ORM: SQL-First Persistence\n\nThe `montrs-orm` package provides a unified, async-first interface for database operations. It prioritizes SQL clarity and type safety over complex abstractions.\n\n## ðŸ—„\u{fe0f} Core Philosophy\n\n-   **SQL-First**: We believe SQL is the best language for querying data. Our ORM makes it easy to write and execute SQL while handling the mapping to Rust structs.\n-   **Backend Agnostic**: Switch between SQLite for local development and PostgreSQL for production with minimal changes.\n-   **Async by Default**: All database operations are non-blocking and integrated with the Tokio runtime.\n\n## ðŸ—\u{fe0f} Models and Rows\n\nDefine your models as standard Rust structs and implement the `FromRow` trait (or use our macros).\n\n```rust\n#[derive(Debug, Serialize, FromRow)]\npub struct User {\n    pub id: i32,\n    pub username: String,\n    pub email: String,\n}\n```\n\n## ðŸ” Querying Data\n\nUse the `db` context within your Loaders and Actions to perform queries.\n\n```rust\nasync fn get_users(ctx: Context) -> Result<Vec<User>> {\n    let users = ctx.db()\n        .query(\"SELECT * FROM users WHERE active = true\")\n        .fetch_all::<User>()\n        .await?;\n    Ok(users)\n}\n```\n\n## ðŸ› \u{fe0f} Mutations\n\nPerform inserts, updates, and deletes using a similar fluent interface.\n\n```rust\nasync fn create_user(ctx: Context, input: CreateUserInput) -> Result<User> {\n    let user = ctx.db()\n        .execute(\"INSERT INTO users (username, email) VALUES ($1, $2) RETURNING *\", \n                 &[input.username, input.email])\n        .fetch_one::<User>()\n        .await?;\n    Ok(user)\n}\n```\n\n## ðŸ¤– Agents and the ORM\n\nFor agents, the ORM layer is where the **Data Model** lives.\n-   **Schema Inference**: By looking at structs implementing `FromRow`, an agent can understand the database schema.\n-   **SQL Generation**: Since we use standard SQL, models can easily generate queries to fetch or modify data.\n-   **Error Resolution**: `DbError` implements `AgentError`, providing specific codes for constraint violations (e.g., unique key conflict), allowing the agent to suggest schema or data fixes.\n",
        "docs/agent\\framework-contributor-prompt.md": "# MontRS Framework Contributor Agent System Prompt\n\nYou are a **Specialized MontRS Framework Contributor AI Agent**. Your mission is to assist in the development, maintenance, and evolution of the MontRS framework itself.\n\n## ðŸŽ¯ Your Core Identity\nYou are a senior Rust systems engineer with deep knowledge of framework design, procedural macros, and developer tooling. You are the guardian of MontRS's architectural invariants.\n\n## ðŸ—\u{fe0f} Framework Principles you MUST Uphold\n- **Determinism**: The framework must be predictable. Avoid non-deterministic behavior in core packages.\n- **Zero-Cost Abstractions**: MontRS should be fast. Use Rust's type system to enforce rules at compile-time whenever possible.\n- **Package Boundaries & Internal Invariants**: Respect the responsibilities of each crate. Every framework package has a `docs/invariants.md` that defines its internal \"rules of engagement\" and boundary constraints. You MUST consult these before and after any change to ensure framework integrity.\n- **Agent-Native**: Every framework feature must be designed with machine-readability in mind. If an agent can't \"understand\" a feature, it's not finished.\n- **Stability**: Prioritize backward compatibility for core traits and schemas.\n\n## ðŸ› \u{fe0f} Your Workflow\n\nFramework contributions must be highly intentional. Follow the specialized workflow that matches your current task:\n\n- **Developing a New Feature?** Follow [Workflow: Adding Features](workflows/adding-features.md).\n- **Resolving Framework Bugs?** Follow [Workflow: Fixing Errors](workflows/fixing-errors.md).\n- **Workspace Restructuring?** Follow [Workflow: Restructuring](workflows/restructuring.md).\n\n### Standard Operational Loop\n1.  **Monitor**: Use `montrs agent list-errors` to identify framework-level regressions, bugs, or architectural violations.\n2.  **Invariants Check**: \n    - Before starting, read the `docs/invariants.md` of the framework package you are modifying.\n    - Verify suggestions don't break the core philosophy or specific internal invariants.\n    - Run `montrs agent check` to statically verify the architectural health of the framework.\n3.  **Implementation**: Focus on robust, well-documented, and highly tested code. Use `@agent-tool` annotations for framework internals.\n4.  **Testing**: Always include unit and integration tests. For CLI changes, verify against real project scaffolds.\n5.  **Documentation**: Ensure every new feature is reflected in `agent.json` and has a corresponding entry in the documentation.\n\n## ðŸ”Œ Utilizing MCP and CLI\nAs a contributor, you must ensure the framework's agentic tools are functional:\n-   **Verify MCP**: Ensure new framework features are exposed correctly via `get_project_snapshot`.\n-   **CLI Diagnostics**: Use `montrs agent doctor` to verify the development environment health.\n\n## ðŸ¤– Interaction Style\n- **Rigorous**: You hold contributors to a high standard. You are not afraid to reject a design that violates MontRS principles.\n- **Visionary**: You look ahead at how framework changes will impact agent-assisted development.\n- **Helpful**: Provide clear guidance on how to implement complex framework features (like new procedural macros or CLI commands).\n\n## ðŸ“š Reference Documents\n- [Architecture Overview](docs/architecture/overview.md)\n- [Invariants & Philosophy](docs/architecture/philosophy.md)\n- [Package Boundaries](docs/architecture/packages.md)\n- [Contributing Guide](docs/community/contributing.md)\n- [Agent-First Design](docs/agent/agent-first.md)\n\n---\n*Remember: You are building the engine that powers the next generation of applications. Precision and consistency are paramount.*\n",
        "packages/cli/docs/agent-command-specs.md": "# MontRS Agent Command Specifications\r\n\r\nThis document defines the behavior and invariants for the `montrs agent` subcommands.\r\n\r\n---\r\n\r\n## 1. `montrs agent check`\r\n\r\n**Purpose**: Validate structural correctness and catch obvious agent-hostile patterns.\r\n\r\n### Inputs\r\n- `--path`: Directory to check (default: current).\r\n- `--level`: Strictness level (relaxed, standard, strict).\r\n\r\n### Invariants\r\n- Must be **read-only**.\r\n- Must be **fast** (sub-second for most projects).\r\n- Must validate:\r\n  - Valid `montrs.toml`.\r\n  - Package dependency cycles.\r\n  - Correct `Plate` and `Route` trait implementations (structural check).\r\n  - Presence of required Scaffolded Explicit headers.\r\n\r\n### Output\r\n- **Human**: Success message or a list of structural violations.\r\n- **AI**: JSON object with `valid: bool` and a list of `violations` including file paths and line numbers.\r\n\r\n---\r\n\r\n## 2. `montrs agent doctor`\r\n\r\n**Purpose**: Assess if the project is \"safe and understandable\" for an AI agent.\r\n\r\n### Inputs\r\n- `--package`: Optional package name to focus on.\r\n\r\n### Responsibilities\r\n- Verifies documentation coverage for public traits.\r\n- Checks for `@agent-tool` marker consistency.\r\n- Detects \"magic\" or highly coupled patterns that lack explicit interfaces.\r\n- Analyzes error history (if available) to find recurring confusion points.\r\n\r\n### Output\r\n- **Human**: A \"health report\" with explanations of WHY certain patterns are problematic.\r\n- **AI**: Structured diagnostics including `severity` (info, warning, error), `invariant_violated`, and `suggested_remediation`.\r\n\r\n---\r\n\r\n## 3. `montrs agent diff`\r\n\r\n**Purpose**: Show a diagnostic diff for an error file, including the error description, the code that produced it, and the suggested fix with the fixed code.\r\n\r\n### Inputs\r\n- `--path`: Path to the error file or diagnostic report.\r\n\r\n### Design Expectations\r\n- Identifies the specific code block causing the error.\r\n- Displays the error message and context.\r\n- Provides a \"Before\" vs \"After\" diff showing the suggested fix.\r\n\r\n### Output\r\n- **Human**: A clear, color-coded diff showing the error, offending code, and proposed fix.\r\n- **AI**: A JSON structure containing the `error`, `original_code`, and `fixed_code`.\r\n",
        "packages/fmt/docs/agent-guide.md": "# Agent Guide: montrs-fmt\n\nThis guide helps agents understand the formatting system of MontRS.\n\n## Core Concepts\n\n### 1. Comment Preservation\nUnlike many Rust formatters, `montrs-fmt` is designed to preserve non-doc comments. This is crucial for agents that use comments as metadata or instructions.\n\n### 2. Macro Formatting\nSpecifically handles `view!` macros. If you are generating UI code, ensure it follows the expected syntax for `view!`.\n\n### 3. The Cascade of Truth\nConfiguration follows a strict hierarchy: CLI > `montrs-fmt.toml` > `montrs.toml` > Defaults.\n\n## Agent Usage Patterns\n\n### Formatting Generated Code\nAfter generating a large amount of code, you can use `montrs fmt` to ensure it adheres to the project's style. This helps in maintaining consistency and reducing linter errors.\n\n### Troubleshooting Parse Errors\nIf `montrs fmt` returns a `FMT_PARSE` error, it means the generated code has syntax errors. Use the `explanation` in the `AgentError` to locate the fault.\n",
        "packages/cli/docs/invariants.md": "# CLI Package Invariants\n\n## 1. Responsibility\n`montrs-cli` is the orchestration hub. It coordinates project lifecycles, builds, and agent-specific metadata generation.\n\n## 2. Invariants\n- **Delegated Logic**: Business and framework logic must reside in `montrs-core`. The CLI only handles orchestration and execution.\n- **Idempotency**: Scaffolding and generation commands should be idempotent where possible. Running `montrs generate` twice should not result in corrupted state.\n- **Agent Synchronization**: Any command that modifies project structure or configuration MUST trigger an update to the `.agent/` directory.\n- **Subcommand Isolation**: Commands (e.g., `build`, `serve`, `generate`) should remain modular and not share mutable state.\n- **External Tooling**: The CLI must wrap external tools (cargo, wasm-pack) rather than reimplementing their functionality.\n\n## 3. Boundary Definitions\n- **In-Scope**: CLI argument parsing, command execution, template management, task running.\n- **Out-of-Scope**: Application business logic, core framework trait definitions, direct code compilation.\n\n## 4. Agent Guidelines\n- Always verify that a command has a corresponding spec in `command/mod.rs`.\n- When adding a new command, ensure it implements proper error reporting via `AgentError`.\n- Use the `utils.rs` helpers for common file operations to ensure consistency.\n",
        "docs/core\\errors.md": "# Structured Error Handling & Versioned ErrorFiles\n\nIn MontRS, errors are not just strings; they are **data**. This document describes how the framework handles failures and how the versioned errorfile system works.\n\n## ðŸ§¬ The `AgentError` Trait\n\nEvery core error in MontRS implements the `AgentError` trait, which provides:\n\n-   `error_code`: A unique identifier for the error type (e.g., `E001`).\n-   `explanation`: A detailed description of why the error occurred.\n-   `suggested_fixes`: A list of actionable steps to resolve the issue.\n-   `subsystem`: The part of the framework where the error originated.\n\n## ðŸ“‚ The `.agent/errorfiles` System\n\nWhen the CLI encounters an error, it doesn't just print it to the terminal. It records it in a versioned history:\n\n1.  **Detection**: An error occurs during a command (e.g., `montrs build`).\n2.  **Recording**: A new `errorfile.json` is created in `.agent/errorfiles/vN/`.\n3.  **Context**: The file includes the error data, timestamp, and a snapshot of the relevant code.\n4.  **Resolution**: When the same command is run and succeeds, the system:\n    -   Identifies the previously failed state.\n    -   Generates a **diff** between the failing code and the fixed code.\n    -   Stores the diff in the error directory as a \"lesson learned.\"\n\n## ðŸ› \u{fe0f} Practical Example: Implementing `AgentError`\n\nIf you are building a custom package, here is how you should implement error handling:\n\n```rust\nuse montrs::prelude::*;\nuse thiserror::Error;\n\n#[derive(Error, Debug, AgentError)]\npub enum MyPackageError {\n    #[error(\"Database connection failed: {0}\")]\n    #[agent(code = \"MP001\", explanation = \"Could not connect to the DB. Check your DATABASE_URL.\")]\n    DbConnection(String),\n    \n    #[error(\"Validation failed: {0}\")]\n    #[agent(code = \"MP002\", explanation = \"Input data was malformed.\")]\n    Validation(String),\n}\n```\n\n---\n\n## ðŸ” The Error Lifecycle\n\n1.  **Failure**: `montrs build` fails with `E042`.\n2.  **Snapshot**: `.agent/errorfiles/v1/E042_timestamp.json` is generated.\n3.  **Fix**: The developer (or agent) modifies the code.\n4.  **Verification**: `montrs build` runs again and succeeds.\n5.  **Learning**: The CLI notices the fix, computes the diff, and saves it. Future agents can now see exactly how `E042` was resolved in this specific project context.\n",
        "docs/getting-started\\golden-path.md": "# The Golden Path: Building with MontRS\n\nThe \"Golden Path\" represents the most effective, idiomatic way to build applications with MontRS. Following these patterns ensures your app remains deterministic, testable, and agent-friendly.\n\n## 1. Start with the Schema\n\nBefore writing any logic, define the data shape. Use `#[derive(Schema)]` for all inputs and outputs.\n\n```rust\n#[derive(Schema, Serialize, Deserialize)]\npub struct CreateTodoInput {\n    #[schema(min_len = 1)]\n    pub title: String,\n}\n```\n\n## 2. Define a Unified Route\n\nInstead of mixing data fetching and mutations randomly, use the `Route` trait to unify everything related to a URL path.\n\n- **Params**: Define what inputs the URL accepts.\n- **Loader**: Fetch side-effect free state for the view.\n- **Action**: Handle validation, persistence, and mutation results.\n- **View**: Define the visual representation.\n\n## 3. Modularize with Plates\n\nGroup related routes into a `Plate`. If the functionality is reusable across projects, package it as a standalone crate.\n\n```rust\nimpl Plate<AppConfig> for TodoPlate {\n    fn register_routes(&self, router: &mut Router<AppConfig>) {\n        router.register(TodoListRoute);\n        router.register(TodoCreateRoute);\n    }\n}\n```\n\n## 4. Prioritize Determinism in Tests\n\nUse `montrs-test` to write tests that are fast and reliable. Avoid external dependencies in unit tests by using our built-in mocks and fixtures.\n\n## 5. Embrace agent-first metadata\n\nAlways provide a `description()` for your loaders and actions. This small effort pays off significantly when an agent needs to understand or modify your code.\n\n## 6. Use the CLI for Orchestration\n\nRely on `montrs build`, `montrs serve`, and `montrs test` instead of raw `cargo` commands. The CLI handles framework-specific optimizations and context updates.\n\n## 7. Versioned Error Handling\n\nWhen errors occur, implement `AgentError`. This provides the agent (and you) with structured data to resolve issues quickly.\n",
        "docs/tooling\\cli.md": "# montrs CLI Reference\n\nThe `montrs` CLI is the primary tool for managing MontRS applications.\n\n## General Flags\n\n- `--release`: Build artifacts in release mode.\n- `--hot-reload`: Enable partial hot-reloading.\n- `--verbose`, `-v`: Increase logging verbosity.\n- `--features`: Specify features to use during compilation.\n\n## Commands\n\n### `new`\nScaffold a new MontRS project from a template.\n```bash\nmontrs new <name> [--template <template>]\n```\n\n### `build`\nBuild the project for production.\n```bash\nmontrs build\n```\n\n### `serve`\nStart the development server with hot-reloading.\n```bash\nmontrs serve\n```\n\n### `bench`\nRun performance benchmarks.\n\n**Arguments:**\n- `target`: (Optional) The target file, directory, or filter.\n\n**Flags:**\n- `--iterations <N>`: Number of benchmark iterations (default: 100).\n- `--warmup <N>`: Number of warmup runs (default: 10).\n- `--timeout <SECONDS>`: Maximum execution time for each benchmark.\n- `--filter <STRING>`: Filter benchmarks by name.\n- `--json-output <PATH>`: Export results to a JSON file.\n- `--generate-weights <PATH>`: Generate a Rust file with weight constants (Substrate-style).\n- `--simple`: **Native Mode**. Benchmarks a file/binary directly without project overhead. Requires `target`.\n\n**Examples:**\n```bash\n# Standard project benchmarks\nmontrs bench\n\n# Native benchmark of a script\nmontrs bench --simple scripts/process_data.rs\n```\n\n### `fmt`\nFormat the project's Rust and view! code.\n\n**Arguments:**\n- `path`: (Optional) The file or directory to format (default: `.`).\n\n**Flags:**\n- `--check`: Verifies if files are formatted without modifying them.\n- `--verbose`: Show detailed output.\n\n**Examples:**\n```bash\n# Format everything\nmontrs fmt\n\n# Check formatting in CI\nmontrs fmt --check\n```\n\n### `test`\nRun project tests (Unit, Integration, E2E).\n```bash\nmontrs test [--filter <name>] [--report <format>]\n```\n\n### `spec`\nGenerate a machine-readable specification of the project.\n```bash\nmontrs spec [--format <json|yaml|txt>]\n```\nThis command refreshes the `.agent/agent.json` file used by agents.\n\n### `run`\nRun custom tasks defined in `montrs.toml`.\n```bash\nmontrs run <task_name>\n```\n\n### `sketch`\nGenerate a single-file, explicit \"sketch\" of a MontRS component. This is the first step in the **Scaffolded Explicit** workflow.\n```bash\nmontrs sketch <name> [--kind <plate|route|app>]\n```\n\n### `expand`\nExpand a `.sketch.rs` file into a full project structure with explicit imports and manual registration.\n```bash\nmontrs expand <path_to_sketch>\n```\n\n### `generate`\nGenerate boilerplate for plates and routes. This is the preferred way to add new components to your application to maintain the **Productive Explicitness** principle.\n\n**Subcommands:**\n\n- **`plate <name>`**: Generates a new `Plate` implementation in `src/plates/`.\n- **`route <path> --plate <name>`**: Generates a new unified `Route` implementation (Params, Loader, Action, View) within the specified plate's directory.\n\n**Examples:**\n```bash\n# Create a new Auth plate\nmontrs generate plate Auth\n\n# Add a login route to the Auth plate\nmontrs generate route /login --plate Auth\n```\n\n## ðŸ¤– Agent-first CLI\n\nMontRS CLI is built to be a primary communication channel between the developer and agents:\n\n- **Error Capturing**: When a command fails, the CLI generates a versioned `errorfile.json` in `.agent/errorfiles/`.\n- **Context Awareness**: The CLI knows the state of your project through the `.agent` folder, allowing it to provide smarter error messages and suggested fixes.\n\n### `watch`\nWatch for changes and rebuild automatically.\n```bash\nmontrs watch\n```\n\n### `upgrade`\nUpgrade the montrs CLI to the latest version.\n```bash\nmontrs upgrade\n```\n",
        "docs/guides\\common-mistakes.md": "# Common Mistakes in MontRS (Router & CLI Edition)\r\n\r\nThis guide outlines the most frequent architectural and operational pitfalls encountered by developers and agents building with MontRS. Following these guidelines ensures your application remains deterministic, testable, and agent-readable.\r\n\r\n---\r\n\r\n## 1. Why These Mistakes Are Common\r\n\r\nMontRS introduces a paradigm shift that can be counter-intuitive for those coming from other ecosystems:\r\n- **The \"React/MVC\" Hangover**: Most users come from React, MVC, or backend-only Rust. They expect components to own data fetching or routes to act as controllers.\r\n- **Routes are Boundaries, Not Controllers**: In MontRS, a route is a resource boundary (Loader/Action), not a place to write business logic.\r\n- **The CLI is the Source of Truth**: The CLI-driven structure (Plates and File-based routing) can feel restrictive at first because it prioritizes predictability over \"clever\" manual wiring.\r\n\r\n---\r\n\r\n## 2. Routing Mistakes (Highest Priority)\r\n\r\n### âŒ Treating Loaders as Services\r\n- **What people do**: Writing complex business logic, database queries, or third-party API calls directly inside a `Loader`.\r\n- **Why it feels reasonable**: It's faster to write everything in one place.\r\n- **Why it breaks MontRS**: It bypasses the `Plate` boundary, making logic hard to reuse and nearly impossible to mock correctly in `TestRuntime`.\r\n- **Correct Approach**: Keep Loaders thin. Call a method on a service injected into a `Plate`.\r\n\r\n### âŒ Direct Database Access in Loaders\r\n- **What people do**: Hardcoding database connections or raw `sqlx` calls inside every loader.\r\n- **Why it feels reasonable**: \"I just need one quick query.\"\r\n- **Why it breaks MontRS**: Bypasses connection pooling and backend abstraction provided by the framework.\r\n- **Correct Approach**: Use the `ctx.db()` provided by the framework within a `Plate` service.\r\n\r\n### âŒ Mutating State in Loaders\r\n- **What people do**: Updating a database record or changing a `Signal` inside a `load()` function.\r\n- **Why it feels reasonable**: \"I just need to increment a view counter while I fetch the post.\"\r\n- **Why it breaks MontRS**: Loaders are meant to be pure read operations. Mutating state in a loader causes unpredictable side effects during SSR and hydration.\r\n- **Correct Approach**: Use an `Action` for all mutations.\r\n\r\n### âŒ Fetching Inside Components\r\n- **What people do**: Using `tokio::spawn` or raw HTTP clients inside a Leptos component.\r\n- **Why it feels reasonable**: Standard practice in many SPA frameworks.\r\n- **Why it breaks MontRS**: It hides data requirements from the Router and Agent. The application spec (`agent.json`) will be incomplete, and SSR will fail to pre-fetch the data.\r\n- **Correct Approach**: Always use a `Loader`. Let the Router provide the data to your view.\r\n\r\n### âŒ Skipping Schema Validation\r\n- **What people do**: Using raw `Value` or unvalidated structs for API inputs.\r\n- **Why it feels reasonable**: \"The input is simple, I don't need a full schema.\"\r\n- **Why it breaks MontRS**: Breaks data integrity and deprives agents of the metadata needed to understand valid inputs.\r\n- **Correct Approach**: Always use `#[derive(Schema)]` for all input and output types.\r\n\r\n### âŒ Over-Flattening Routes\r\n- **What people do**: Putting all route logic into a single large file or avoiding nested directories.\r\n- **Why it feels reasonable**: Avoids \"folder sprawl.\"\r\n- **Why it breaks MontRS**: MontRS uses file-based routing to build a static route graph. Flattening removes the hierarchy needed for nested layouts and inherited context.\r\n- **Correct Approach**: Follow the file-based hierarchy (`routes/users/[id].rs`).\r\n\r\n### âŒ Avoiding Nested Layouts\r\n- **What people do**: Re-implementing sidebars or headers in every single route view.\r\n- **Why it feels reasonable**: \"I want full control over every pixel in this specific view.\"\r\n- **Why it breaks MontRS**: Increases boilerplate and breaks the \"intent\" of the route tree.\r\n- **Correct Approach**: Define a `layout()` in a parent `mod.rs` to wrap all children.\r\n\r\n---\r\n\r\n## 3. CLI & Structure Mistakes\r\n\r\n### âŒ Ignoring CLI Scaffolding\r\n- **What people do**: Manually creating files and directories instead of using `montrs new` or `montrs generate`.\r\n- **Why it feels reasonable**: \"I know exactly where I want my files.\"\r\n- **Why it breaks MontRS**: You might miss critical boilerplate that the CLI handles for agent-readiness.\r\n- **Correct Approach**: Start with `montrs` commands and modify from there.\r\n\r\n### âŒ Mixing Business Logic in Main\r\n- **What people do**: Putting all route registrations and business logic in `main.rs`.\r\n- **Why it feels reasonable**: \"It's a small app, I don't need multiple files yet.\"\r\n- **Why it breaks MontRS**: Violates modularity and makes the app hard to scale or test.\r\n- **Correct Approach**: Use `Plate` implementations to keep your application organized and composable.\r\n\r\n### âŒ Renaming Folders Arbitrarily\r\n- **What people do**: Renaming `plates/` to `modules/` or `src/` to `code/`.\r\n- **Why it feels reasonable**: Personal preference or legacy project alignment.\r\n- **Why it breaks MontRS**: The discovery engine expects a specific structure. Breaking it makes your app invisible to the spec generator.\r\n- **Correct Approach**: Stick to the standard MontRS directory structure.\r\n\r\n### âŒ Manual Spec/Snapshot Edits\r\n- **What people do**: Trying to manually edit `.agent/agent.json`.\r\n- **Why it feels reasonable**: \"I just need to fix one description quickly.\"\r\n- **Why it breaks MontRS**: The file is auto-generated; manual changes will be overwritten.\r\n- **Correct Approach**: Update your source code (traits/comments) and run `montrs spec`.\r\n\r\n---\r\n\r\n## 4. State & Reactivity Mistakes\r\n\r\n### âŒ Global Signals\r\n- **What people do**: Declaring `static` signals or global mutable state.\r\n- **Why it feels reasonable**: Easiest way to share state across the entire app.\r\n- **Why it breaks MontRS**: Breaks **State Locality**. It makes the app non-deterministic and causes race conditions during concurrent SSR requests.\r\n- **Correct Approach**: Keep state in `Plates` or pass `Signals` through context.\r\n\r\n### âŒ Hidden Mutation\r\n- **What people do**: Changing a value deep inside a struct without going through an `Action`.\r\n- **Why it feels reasonable**: \"It's just a small internal flag.\"\r\n- **Why it breaks MontRS**: Mutations must be explicit to be auditable by the framework and agent.\r\n- **Correct Approach**: Use an `Action` or a `Signal::set()` call.\r\n\r\n---\r\n\r\n## 5. Plate Misuse (Router Interaction)\r\n\r\n### âŒ Calling Routes from Plates\r\n- **What people do**: Trying to invoke a `Loader` directly from a `Plate` service.\r\n- **Why it feels reasonable**: \"I need the same data the UI needs.\"\r\n- **Why it breaks MontRS**: Creates circular dependencies. Loaders depend on Plates, not the other way around.\r\n- **Correct Approach**: Extract the shared logic into a separate service method within the Plate.\r\n\r\n### âŒ Skipping Plates for \"Small\" Side Effects\r\n- **What people do**: Putting raw `sqlx` calls directly in a Route Action.\r\n- **Why it feels reasonable**: \"It's just one query.\"\r\n- **Why it breaks MontRS**: Violates the **Side Effect Isolation** invariant and makes the route untestable.\r\n- **Correct Approach**: Always wrap side effects (DB, Network, Disk) in a `Plate`.\r\n\r\n---\r\n\r\n## 6. Testing & Debugging Mistakes\r\n\r\n### âŒ Testing UI Instead of Behavior\r\n- **What people do**: Writing 100% Playwright E2E tests for basic business logic.\r\n- **Why it feels reasonable**: \"It's the only way to be sure it actually works.\"\r\n- **Why it breaks MontRS**: E2E tests are slow and flaky. MontRS is designed for deterministic logic testing.\r\n- **Correct Approach**: Test the `Loader` and `Action` logic using `TestRuntime`.\r\n\r\n### âŒ Avoiding TestRuntime / Non-Deterministic Tests\r\n- **What people do**: Relying on global state, system time, or live production databases in tests.\r\n- **Why it feels reasonable**: \"I want to test with real data.\"\r\n- **Why it breaks MontRS**: Tests become non-deterministic and flaky.\r\n- **Correct Approach**: Use `montrs-test` fixtures and `TestRuntime` to mock the environment.\r\n\r\n---\r\n\r\n## 7. \"This Is Intentional\" (Router Edition)\r\n\r\nMontRS makes specific trade-offs to ensure machine-readability:\r\n- **Explicit Loaders/Actions**: More typing than a \"hook,\" but 100% discoverable by an agent.\r\n- **No Magic Data Propagation**: Data flows through the `Context`. If it's not there, your logic can't see it.\r\n- **Strict Boundaries**: Separation between `Plate` and `Router` allows one codebase to run on Web, Mobile, and Desktop.\r\n\r\n---\r\n\r\n## 8. Recovery Guide\r\n\r\nIf you've \"fought the framework\":\r\n1.  **Run `montrs spec`**: See what the framework currently \"sees.\"\r\n2.  **Move Logic to Plates**: Extract DB/Network calls from routes.\r\n3.  **Thin Your Loaders**: Loaders should only parse input and call a Plate.\r\n4.  **Align with CLI**: Use `montrs generate` to see the idiomatic pattern for new features.\r\n\r\n---\r\n\r\n## 9. Agent-Specific Guidance (For AI Coding Partners)\r\n\r\nWhen working on a MontRS project, AI agents MUST:\r\n- **Do Not Invent APIs**: Stick to the traits defined in `montrs-core`.\r\n- **Do Not Bypass the CLI**: Think \"How would the CLI scaffold this?\"\r\n- **Provide Agent Metadata**: Never leave `description()` as `None`. It is the primary way other agents (and humans) understand your code's intent.\r\n- **Avoid Complex Macro Logic**: Do not hide business logic inside procedural macros. Prefer explicit traits and functions.\r\n- **Check `.agent/agent.json`**: Ensure your changes are correctly reflected in the project specification.\r\n",
        "packages/cli/docs/mcp-server-design.md": "# MontRS MCP Server Design Document\r\n\r\n## Mental Model\r\n\r\nThe MontRS MCP (Model Context Protocol) server is not a standalone service but a **mode** of the MontRS CLI. It serves as a machine-readable bridge between AI agents and the real MontRS environment. Following the MontRS philosophy of \"Real systems over simulations,\" the MCP server directly invokes the CLI's internal logic to ensure that agents see exactly what the human developer sees.\r\n\r\n## CLI Integration\r\n\r\nThe MCP server is started via the CLI:\r\n```bash\r\nmontrs mcp serve\r\n```\r\nThis command initializes a JSON-RPC 2.0 server over stdio (standard for MCP), allowing agents to discover and invoke MontRS capabilities.\r\n\r\n## API Surface (Conceptual)\r\n\r\n### Resources\r\n\r\n- `montrs://project/structure`: Returns a machine-readable tree of the workspace, packages, and their relationships.\r\n- `montrs://project/router`: Returns the current deterministic router structure, including all registered routes, loaders, and actions.\r\n- `montrs://docs/{package}`: Provides access to package-specific documentation and invariants.\r\n- `montrs://config/current`: Returns the merged configuration from `montrs.toml` and environment variables.\r\n\r\n### Tools\r\n\r\n- `montrs_check`: Invokes `montrs agent check`. Validates project invariants.\r\n- `montrs_doctor`: Invokes `montrs agent doctor`. Returns structured diagnostics on \"agent-readability\".\r\n- `montrs_diff`: Invokes `montrs agent diff`. Generates a diagnostic diff for an error file, showing the error, offending code, and suggested fix.\r\n- `montrs_spec`: Invokes `montrs spec`. Generates a snapshot of the project for agent context.\r\n\r\n### ENDPOINTS (MCP)\r\n\r\n- `list_tools`: Returns available agent tools.\r\n- `call_tool`: Executes a specific CLI capability and returns structured JSON.\r\n- `list_resources`: Returns available project metadata resources.\r\n- `read_resource`: Fetches the content of a specific resource.\r\n\r\n## Safety and Determinism Guarantees\r\n\r\n1. **Read-Only by Default**: The MCP tools are read-only. Modification of the project is left to the human developer or standard IDE tools after reviewing agent suggestions.\r\n2. **Standardized Errors**: All errors follow the `AgentError` trait, providing stable error codes and structured remediation steps.\r\n3. **No Shadow State**: The MCP server always queries the current filesystem. There is no sandboxing or speculative execution.\r\n4. **Human-in-the-Loop**: Agents propose fixes via `montrs_diff`, but the application of these fixes is external to the MontRS Agent CLI, ensuring the human developer remains in control.\r\n\r\n## Human vs Agent Outputs\r\n\r\n- **Human**: CLI output is optimized for terminal readability (colors, progress bars, tables).\r\n- **Agent**: MCP response is optimized for token efficiency and structural parsing (JSON, minimal filler, explicit schema).\r\n",
        "packages/utils/docs/invariants.md": "# Utils Package Invariants\n\n## 1. Responsibility\n`montrs-utils` contains generic, reusable utilities that are used across multiple packages in the workspace.\n\n## 2. Invariants\n- **Side-Effect Free**: Functions in this package should ideally be pure and free of side effects.\n- **Generic Utility**: Only include logic that is truly generic and not specific to a single framework component.\n- **High Stability**: As a low-level dependency, changes here must be carefully vetted for breaking impact.\n\n## 3. Boundary Definitions\n- **In-Scope**: String manipulation, collection helpers, common algorithm implementations.\n- **Out-of-Scope**: Framework-specific logic (Plates, Routes, etc.).\n",
        "docs/agent\\agent-first.md": "# Agent-first integration guide\n\nMontRS is the first Rust framework designed from the ground up to be **Agent-Native**. This guide explains how agents (and the developers who build them) can leverage MontRS's machine-readable infrastructure.\n\n## ðŸš€ The agent-first golden path\n\nTo effectively work with a MontRS project, an agent should:\n\n1.  **Consume the Spec**: Read `.agent/agent.json` to understand the project structure, routes, and available tools.\n2.  **Use the Tools**: Use `tools.json` to identify CLI commands and framework capabilities that can be called as functions.\n3.  **Handle Errors Structurely**: When a task fails, check `.agent/errorfiles/` for the latest `errorfile.json`. It contains the exact error, explanation, and suggested fixes.\n4.  **Learn from History**: Look at resolved error files to see diffs of how similar problems were fixed in the past.\n\n## ðŸ›¡\u{fe0f} Architectural Guardrails: Framework Invariants\n\nA key feature of MontRS's agent-native architecture is **Framework Invariants** (`docs/invariants.md`). \n\n- **Localized Context**: Unlike global documentation, invariants provide high-density rules for a specific framework package or feature.\n- **Contract Verification**: Agents use these files as a \"contract\" to verify that their use of the framework aligns with its intended design.\n- **Automated Checking**: The `montrs agent check` command uses these invariants to statically verify that the project's use of the framework remains healthy.\n\n## ðŸ› \u{fe0f} Metadata & Annotations\n\nAgents should look for the following markers in the codebase:\n\n-   `@agent-tool`: Explicitly marks a function or struct as a tool for the agent.\n-   `AgentError` implementations: Provides structured data for runtime or compile-time failures.\n-   `description()` methods: Found on `Loader`, `Action`, and `Plate` traits.\n\n## ðŸ“ Writing agent-first code\n\nWhen contributing to MontRS or building an app with it, follow these rules to keep it agent-friendly:\n\n1.  **Always implement `description()`**: Don't leave your loaders and actions as \"black boxes.\"\n2.  **Use Structured Errors**: Wrap your errors in types that implement `AgentError`.\n3.  **Keep READMEs Updated**: The `montrs-agent` package scans package READMEs to curate `tools.json`. Use the standard sections (What it is, What it solves, etc.).\n\n## ðŸ¤– For Agents: Self-Correction Loop\n\nIf you encounter an error:\n1.  Run `montrs spec` to refresh the state.\n2.  Read the generated `errorfile.json`.\n3.  Apply the `suggested_fix` or use the `explanation` to derive a new one.\n4.  Run the command again. If it succeeds, MontRS will record the fix as a diff for your future reference.\n",
        "docs/agent\\spec.md": "# The Agent Specification Snapshot (`agent.json`)\n\nThe `agent.json` file, located in the `.agent/` directory, is the primary source of context for agents working on a MontRS project. It is a structured, machine-readable representation of the entire application.\n\n## ðŸ“‚ File Location\n```text\n.agent/\nâ”œâ”€â”€ agent.json        # Primary JSON specification\nâ”œâ”€â”€ agent.yaml        # YAML version (optional)\nâ”œâ”€â”€ agent.txt         # Text summary (optional)\nâ””â”€â”€ errorfiles/       # Versioned history of project errors\n```\n\n## ðŸ—\u{fe0f} Structure of `agent.json`\n\nThe file is divided into several key sections:\n\n### 1. `metadata`\nContains project-wide information:\n- `name`, `version`, `description`.\n- Agent-specific instructions and project context.\n\n### 2. `plates`\nA list of all registered `Plate` implementations found in the project. For each plate:\n- `name`: The Rust struct name.\n- `description`: The string returned by `plate.description()`.\n\n### 3. `routes`\nThe most critical section for application development. Each route is a unified unit containing:\n- `path`: The URL pattern (e.g., `/api/users/:id`).\n- `params`: Metadata about the required URL parameters.\n- `loader`: Metadata about the data-fetching logic (Input/Output).\n- `action`: Metadata about the mutation logic (Input/Output).\n- `metadata`: Key-value pairs describing the route's purpose for agents.\n\n### 4. `tools`\nA curated list of CLI commands and framework capabilities that the agent can invoke as \"tools.\"\n\n## ðŸ”„ Lifecycle\n\n1. **Auto-Update**: The CLI automatically refreshes the spec whenever a command (`build`, `serve`, `test`) is run.\n2. **Manual Update**: You can force a refresh using `montrs spec`.\n3. **Agent Consumption**: Agents should read this file at the start of every session to ensure they have the latest context.\n\n## ðŸ¤– Why Not Just Read the Code?\n\nWhile models *can* read source code, `agent.json` provides:\n- **Pre-computed Metadata**: Descriptions and schemas are extracted and ready to use.\n- **Unified View**: It bridges the gap between different files and packages.\n- **Standardization**: It follows a consistent schema regardless of how the underlying code is structured.\n",
        "packages/montrs/docs/invariants.md": "# MontRS Wrapper Package Invariants\n\n## 1. Responsibility\nThe `montrs` package is a high-level wrapper that provides the primary entry point for users consuming the framework as a single dependency.\n\n## 2. Invariants\n- **Clean Re-exports**: This package must cleanly re-export the public API of core packages (`core`, `orm`, `agent`) to provide a unified experience.\n- **Minimal Logic**: This package should contain minimal unique logic, acting primarily as a facade.\n\n## 3. Boundary Definitions\n- **In-Scope**: Re-exports, high-level convenience macros, meta-documentation.\n- **Out-of-Scope**: Implementation of core framework features.\n",
        "debugging": "\n# Debugging MontRS\nMontRS provides an `errorfile.json` in the `.agent/errorfiles` folder when a build or test fails.\nAgents should use these files to understand the context of the error and propose fixes.\n",
        "docs/agent\\workflows\\new-projects.md": "# Workflow: New Projects & Packages\r\n\r\nThis guide defines how to initialize new MontRS applications and how to add new framework packages to the workspace.\r\n\r\n---\r\n\r\n## ðŸ“± For Application Developers (New Project)\r\n\r\n1.  **Initialize**: Run `montrs new <project_name> --template <template_name>`.\r\n2.  **Onboard**: Run `montrs spec` immediately to generate the initial `.agent/agent.json`.\r\n3.  **Explore**: Read the generated `agent.json` or `agent.txt` to understand the scaffolded structure.\r\n4.  **Configure**: Update `montrs.toml` with project-specific metadata.\r\n5.  **First Plate**: Use `montrs generate plate <name>` to create your first domain boundary.\r\n6.  **Verify**: Run `montrs agent check` to ensure the scaffold is valid.\r\n\r\n---\r\n\r\n## ðŸ—\u{fe0f} For Framework Contributors (New Package)\r\n\r\n1.  **Scaffold**: Create a new directory in `packages/`.\r\n2.  **Initialize**: Run `cargo init --lib`.\r\n3.  **Workspace Link**: Add the new package to the top-level `Cargo.toml` workspace members.\r\n4.  **Agent-Ready**: \r\n    -   Create a `README.md` with mandatory sections (What it is, What it solves, etc.).\r\n    -   Add `montrs-agent` as a dev-dependency if metadata collection is needed.\r\n5.  **Metadata**: Annotate public tools with `@agent-tool`.\r\n6.  **Register**: Run `montrs spec` to ensure the new package appears in the project snapshot.\r\n7.  **Doctor**: Run `montrs agent doctor --package <new_package>` to verify it meets framework standards.\r\n\r\n---\r\n\r\n## ðŸ¤– Agent Instructions (MCP)\r\n-   **Step 1**: Use CLI `montrs new` for apps.\r\n-   **Step 2**: `get_project_snapshot({})` to verify the new structure.\r\n-   **Step 3**: `agent_doctor({\"package\": \"...\"})` for framework contributions.\r\n",
        "docs/orm\\backends.md": "# Database Backends\n\nMontRS ORM is designed to be backend-agnostic, allowing you to use different databases for development, testing, and production with minimal configuration changes.\n\n## ðŸš€ Supported Backends\n\n### 1. SQLite (Default for Dev)\n- **Crate**: `libsqlite3-sys`\n- **Use Case**: Local development, small applications, and edge deployments.\n- **Connection String**: `sqlite://data.db` or `sqlite::memory:`\n\n### 2. PostgreSQL\n- **Crate**: `tokio-postgres`\n- **Use Case**: Production applications requiring high concurrency and advanced features.\n- **Connection String**: `postgres://user:pass@localhost/db`\n\n## âš™\u{fe0f} Configuration\n\nYou can specify the database backend in your `montrs.toml`:\n\n```toml\n[database]\nbackend = \"sqlite\" # or \"postgres\"\nurl = \"env:DATABASE_URL\"\n```\n\n## ðŸ”„ Switching Backends\n\nBecause MontRS uses a trait-based approach for database interactions, your `Loader` and `Action` code remains the same regardless of the backend:\n\n```rust\n// This code works for both SQLite and Postgres\nlet user = ctx.db()\n    .query(\"SELECT * FROM users WHERE id = $1\")\n    .bind(1)\n    .fetch_one::<User>()\n    .await?;\n```\n\n## ðŸ§ª Testing with Backends\n\nWe recommend using `sqlite::memory:` for unit and integration tests to ensure they are fast and deterministic. For E2E tests, you can use a dedicated test PostgreSQL instance or a file-based SQLite database.\n",
        "docs/agent\\workflows\\adding-features.md": "# Workflow: Adding New Features\r\n\r\nThis guide defines the \"Golden Path\" for adding functionality to an app or extending the framework.\r\n\r\n---\r\n\r\n## ðŸ“± For Application Developers\r\n\r\n1.  **Contextualize**: Read the `docs/invariants.md` of the MontRS framework packages you are utilizing. These define the \"rules of engagement\" for using the framework's features correctly.\r\n2.  **Define Schema**: Create input/output structs with `#[derive(Schema)]`.\r\n2.  **Generate Boilerplate**:\r\n    -   Run `montrs generate plate <name>` for new features.\r\n    -   Run `montrs generate route <path> --plate <name>` for new endpoints.\r\n3.  **Implement Unified Route**: \r\n    -   The CLI generates `RouteLoader`, `RouteAction`, and `RouteView`.\r\n    -   Implement the business logic in the `load` and `act` methods.\r\n4.  **Register**:\r\n    -   Add modules to `mod.rs` as instructed by the CLI.\r\n    -   Register the plate in `main.rs` and the route in `Plate::register_routes`.\r\n5.  **Annotate**: Implement `description()` on Loaders and Actions for agent discovery.\r\n6.  **Verify**: Run `montrs spec` and `montrs agent check`.\r\n\r\n---\r\n\r\n## ðŸ—\u{fe0f} For Framework Contributors\r\n\r\n1.  **Invariants Check**: Read `packages/<target>/docs/invariants.md` to understand the internal architectural rules and boundary constraints of the framework package you are modifying.\r\n2.  **Trait Definition**: Define new core traits in `packages/core`.\r\n2.  **Implementation**: Provide default or specialized implementations in relevant packages.\r\n3.  **Macro Support**: If the feature requires automation, update `packages/schema` (procedural macros).\r\n4.  **CLI Integration**: Update `montrs generate` commands in `packages/cli` if the feature requires boilerplate.\r\n5.  **Agent Visibility**: \r\n    -   Update `packages/agent` to collect metadata for the new feature.\r\n    -   Add `@agent-tool` to the new implementation.\r\n6.  **Template Update**: Add an example of the feature to `templates/todo`.\r\n7.  **Final Audit**: Run `montrs spec` and `agent doctor`.\r\n\r\n---\r\n\r\n## ðŸ¤– Agent Instructions (MCP)\r\n-   **Step 1**: Read the relevant framework `docs/invariants.md` before proposing changes to ensure you are using the framework's features as intended.\r\n-   **Step 2**: Use `montrs generate` tools whenever possible to ensure architectural consistency.\r\n-   **Step 3**: Follow the **Golden Path** (Schema -> Generation -> Implementation -> Registration).\r\n-   **Step 4**: Always add `description()` to Loaders and Actions.\r\n-   **Step 5**: `agent_check({})` to verify compliance.\r\n",
        "packages/orm/docs/invariants.md": "# ORM Package Invariants\n\n## 1. Responsibility\n`montrs-orm` provides a type-safe, agent-readable interface for database operations and migrations.\n\n## 2. Invariants\n- **Backend Agnostic**: Core traits must remain independent of specific database backends (SQL, NoSQL, etc.).\n- **Type-Safe Queries**: All queries should be validated at compile-time or through type-safe DSLs defined in this package.\n- **Deterministic Migrations**: Migration logic must be reversible and idempotent.\n\n## 3. Boundary Definitions\n- **In-Scope**: DB traits, migration orchestration, type-safe query builders.\n- **Out-of-Scope**: Direct network handling (delegated to drivers), application business logic.\n",
    },
}