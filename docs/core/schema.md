# Schema & Validation: Type-Safe Data

MontRS leverages a declarative schema system powered by `montrs-schema`. It allows you to define data structures that are automatically validated at the boundaries of your application.

---

## üìú The `#[derive(Schema)]` Macro

The core of the system is the `Schema` derive macro. It generates validation logic and machine-readable metadata for your structs.

```rust
use montrs::prelude::*;

#[derive(Schema, Serialize, Deserialize)]
pub struct CreateUserInput {
    #[schema(min_len = 3, max_len = 50)]
    pub username: String,
    
    #[schema(email)]
    pub email: String,
    
    #[schema(min = 18)]
    pub age: i32,
}
```

---

## ‚úÖ Validation Lifecycle

1.  **Incoming Request**: A JSON payload arrives at an `Action`.
2.  **Deserialization**: The data is deserialized into the struct using `serde`.
3.  **Validation**: The `validate()` method (generated by `#[derive(Schema)]`) is called.
4.  **Error Handling**: If validation fails, a structured `ValidationError` (implementing `AiError`) is returned, including details on which fields failed and why.

---

## üõ†Ô∏è Supported Constraints

-   `min_len`, `max_len`: For strings and collections.
-   `min`, `max`: For numeric values.
-   `email`: Validates email format.
-   `regex`: Matches against a custom regular expression.
-   `custom`: Invokes a custom validation function.

---

## üõ†Ô∏è Practical Example: Using Schema in an Action

Here is how you use a schema-validated struct in a real-world `Action`:

```rust
use montrs::prelude::*;
use crate::models::User;

#[derive(Schema, Serialize, Deserialize)]
pub struct UpdateProfileInput {
    #[schema(min_len = 2)]
    pub display_name: Option<String>,
    #[schema(max_len = 255)]
    pub bio: Option<String>,
}

pub struct UpdateProfileAction;

#[async_trait]
impl Action for UpdateProfileAction {
    async fn call(&self, ctx: Context) -> Result<Value> {
        // ctx.input() automatically deserializes and validates 
        // against UpdateProfileInput's constraints.
        let input: UpdateProfileInput = ctx.input()?; 
        
        let user_id = ctx.user_id()?;
        let updated_user = db::update_profile(user_id, input).await?;
        
        Ok(json!(updated_user))
    }
}
```

---

## üîç Advanced Validation: Custom Rules

Sometimes built-in constraints aren't enough. You can define custom validation logic:

```rust
#[derive(Schema, Serialize, Deserialize)]
pub struct PasswordResetInput {
    pub password: String,
    #[schema(custom = "validate_confirm_password")]
    pub confirm_password: String,
}

fn validate_confirm_password(input: &PasswordResetInput) -> Result<(), ValidationError> {
    if input.password != input.confirm_password {
        return Err(ValidationError::new("confirm_password", "Passwords must match"));
    }
    Ok(())
}
```

---

## ü§ñ AI and Schemas

Schemas are the **API Contract**. In the `AppSpec`, every `Loader` and `Action` can specify its input and output schemas.

### Common AI Failure Modes
- **Anti-Pattern**: Forgetting `#[derive(Schema)]` on a new input struct.
  - *Fix*: AI agents must ensure every struct used in `ctx.input()` implements `Schema`.
- **Anti-Pattern**: Using `String` for data that has a known format (like email).
  - *Fix*: Use `#[schema(email)]` to provide better hints to the validation engine and the AI.
- **Anti-Pattern**: Complex logic inside the `Schema` definition.
  - *Fix*: Use `custom` validation functions for complex logic to keep the struct definition clean and readable.
