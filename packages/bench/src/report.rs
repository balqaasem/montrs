use crate::stats::BenchStats;
use crate::sys::SystemInfo;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// A full benchmark report containing system info and results.
///
/// This structure is serializable to JSON for external analysis.
#[derive(Debug, Serialize, Deserialize)]
pub struct Report {
    /// Information about the system where the benchmark was run.
    pub system: SystemInfo,
    /// A map of benchmark names to their results.
    pub results: HashMap<String, BenchResult>,
    /// The timestamp when the report was created.
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

/// The result of a single benchmark execution.
#[derive(Debug, Serialize, Deserialize)]
pub struct BenchResult {
    /// Statistical analysis of the run.
    pub stats: BenchStats,
    /// Total number of iterations performed.
    pub iterations: u32,
    /// Total wall-clock time for all iterations (excluding warmup).
    pub total_duration_secs: f64,
}

impl Report {
    /// Creates a new, empty report with current system info.
    pub fn new() -> Self {
        Self {
            system: SystemInfo::collect(),
            results: HashMap::new(),
            timestamp: chrono::Utc::now(),
        }
    }

    /// Adds a result to the report.
    pub fn add_result(&mut self, name: String, stats: BenchStats, iterations: u32, total_duration_secs: f64) {
        self.results.insert(name, BenchResult {
            stats,
            iterations,
            total_duration_secs,
        });
    }

    /// Saves the report to a JSON file.
    pub fn save_json(&self, path: &str) -> anyhow::Result<()> {
        let file = std::fs::File::create(path)?;
        serde_json::to_writer_pretty(file, self)?;
        Ok(())
    }

    /// Generates a Rust file containing weight constants (Substrate-style).
    pub fn save_weights(&self, path: &str) -> anyhow::Result<()> {
        use std::io::Write;

        let mut file = std::fs::File::create(path)?;
        writeln!(file, "//! Autogenerated weights for benchmark results")?;
        writeln!(file, "//! Generated by MontRS Bench on {}", self.timestamp)?;
        writeln!(file, "")?;
        writeln!(file, "#![allow(unused_parens)]")?;
        writeln!(file, "#![allow(unused_imports)]")?;
        writeln!(file, "")?;

        // Sort keys for deterministic output
        let mut keys: Vec<_> = self.results.keys().collect();
        keys.sort();

        for name in keys {
            let result = &self.results[name];
            // Sanitize name for use as a module/constant
            let safe_name = name.replace(|c: char| !c.is_alphanumeric(), "_").to_uppercase();
            
            // We export a struct-like module or just constants
            writeln!(file, "/// Weight for {}", name)?;
            writeln!(file, "pub mod {} {{", safe_name.to_lowercase())?;
            
            // Base time (intercept) in nanoseconds
            // result.stats.mean is in seconds.
            // result.stats.intercept is in seconds (if present).
            // result.stats.slope is seconds per unit.

            // Correct conversion:
            let base_ns = if let Some(intercept) = result.stats.intercept {
                intercept * 1e9
            } else {
                result.stats.mean * 1e9
            };

            let slope_ns = if let Some(s) = result.stats.slope {
                s * 1e9
            } else {
                0.0
            };

            writeln!(file, "    /// Base execution time in nanoseconds")?;
            writeln!(file, "    pub const BASE_NS: f64 = {:.2};", base_ns)?;
            writeln!(file, "    /// Slope execution time in nanoseconds per unit")?;
            writeln!(file, "    pub const SLOPE_NS: f64 = {:.2};", slope_ns)?;
            writeln!(file, "}}")?;
            writeln!(file, "")?;
        }

        Ok(())
    }
}
